# Импортируем тип Optional из модуля typing.
# Это нужно для аннотации типов, чтобы указать, что переменная может быть
# либо объектом ListNode, либо None.
from typing import Optional

# Заводим класс узла связного списка.
class ListNode:
    # __init__ - конструктор класса.
    # val=0 - значение узла по умолчанию 0.
    # next=None - указатель на следующий узел по умолчанию None.
    # self.val - сохраняет переданное значение в узел.
    # self.next - сохраняет ссылку на следующий узел.
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Определяем метод removeNthFromEnd, который принимает ряд параметров.
    # head - голова связного списка (может быть None).
    # n - номер узла с конца, который нужно удалить. Целое число.
    # -> Optional[ListNode] - возвращает новую голову списка или None.
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:

        # Создаём фиктивный узел.
        # Зачем это нужно?
        # Фиктивный узел решает проблему удаления первого узла.
        # Если мы удаляем первый узел, то slow будет указывать на dummy, что
        # позволяет корректно перенаправить указатели.

        # dummy = ListNode(0) - создаём новый фиктивный узел со значением 0.
        dummy = ListNode(0)
        # dummy.next = head - связываем фиктивный узел с головой списка.
        dummy.next = head

        # Создаём указатели.
        # Создаём 2 указателя - fast и slow, которые изначально указывают на фиктивный узел.
        # Техника "быстрый и медленный указатель" позволяет найти нужную позицию за один проход.
        fast = dummy
        slow = dummy

        # Создаём разрыв между указателями.

        # Цикл выполняется n + 1 раз.
        # На каждой итерации fast перемещается на следующий узел.
        # После цикла между fast и slow образуется разрыв в n узлов.
        # Почему n + 1? Потому что оба стартуют с фиктивного узла, и чтобы создать
        # разрыв в n узлов, нужно сместить fast на n+1 позиций.
        for i in range(n + 1):
            fast = fast.next

        # Поиск узла перед удаляемым.
        # Пока fast не равен None (пока не достигли конца списка):
        # fast перемещается на следующий узел,
        # slow перемещается на следующий узел.
        # Когда цикл завершится, slow указывает на узел, который находится ПЕРЕД удаляемым узлом.
        # Почему? Потому что между fast и slow изначально было n узлов, и когда fast дошёл до
        # конца, slow оказался на n позиций раньше конца.
        while fast:
            fast = fast.next
            slow = slow.next

        # Удаление узла.
        # slow.next - это указатель на удалаемый узел.
        # slow.next.next - это указатель на узел после удаляемого.
        # Перенаправляя slow.next на slow.next.next, мы исключаем удаляемый узел из цепочки.
        # Если удалялся последний узел, то slow.next.next будет None, что корректно.
        slow.next = slow.next.next

        # Возвращаем dummy.next - новую голову списка.
        # dummy.next всегда указывает на голову изменённого списка, даже если мы удалили первый узел.
        # Если список стал пустым, вернётся None.
        return dummy.next