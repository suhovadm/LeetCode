# Remove Nth Node From End of List

# Учитывая начало (голову) связного списка, удалите n-й узел с конца списка и верните его начало.

# Пример 1:
# Вход: head = [1, 2, 3, 4, 5], n = 2
# Выход: [1, 2, 3, 5]

# Пример 2:
# Вход: head = [1], n = 1
# Выход: []

# Пример 3:
# Вход: head = [1, 2], n = 1
# Выход: [1]

# Ограничения:
# Количество узлов в списке равно sz.
# 1 <= sz <= 30
# 0 <= значение узла <= 100
# 1 <= n <= sz

# Дополнительно: можете ли вы решить эту задачу за один проход (один обход списка)?

from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:

        dummy = ListNode(0)
        dummy.next = head

        fast = dummy
        slow = dummy

        for i in range(n + 1):
            fast = fast.next

        while fast:
            fast = fast.next
            slow = slow.next

        slow.next = slow.next.next

        return dummy.next

# Как это работает:

# 1. Фиктивный узел (dummy): создаём фиктивный узел перед головой списка.
# Это упрощаёт обработку случая, когда нужно удалить первый узел.

# 2. Два указателя: используем два указателя - fast и slow, оба начинают с фиктивного узла.

# 3. Создание разрыва: сдвигаем fast на n+1 шагов вперёд. Теперь между fast и slow ровно n узлов.

# 4. Поиск цели: двигаем оба указателя, пока fast не достигнет конца. Когда это произойдёт, slow
# будет указывать на узел, предшествующий удаляемому.

# 5. Удаление: удаляем нужный узел, перенаправляя указатель slow.next на slow.next.next.

# 6. Результат: возвращаем dummy.next, который указывает на голову изменённого списка.

# Временная сложность: O(L) - где L длина списка (один проход).
# Пространственная сложность: O(1) - используя только константное количество дополнительной памяти.