# Number of Steps to Reduce a Number in Binary Representation to One

# Задача: количество шагов для преобразования двоичного числа в еденицу.

# Имея двоичное представление целого числа в виде строки s, верните количество шагов,
# необходимых для преобразования этого числа в 1 в соответствии со следующими правилами:

# 1. Если текущее число четное, разделите его на 2.
# 2. Если текущее число нечетное, прибавьте к нему 1.

# Гарантируется, что для всех тестовых случаев вы всегда сможете достичь еденицы.

# Пример 1:
# Входные данные: s = "1101"
# Результат: 6
# Пояснение: "1101" соответствует десятичному числу 13.
# Шаг 1) 13 - нечетное, добавляем 1 и получаем 14.
# Шаг 2) 14 - четное, делим на 2 и получаем 7.
# Шаг 3) 7 - нечетное, добавляем 1 и получаем 8.
# Шаг 4) 8 - четное, делим на 2 и получаем 4.
# Шаг 5) 4 - четное, делим на 2 и получаем 2.
# Шаг 6) 2 - четное, делим на 2 и получаем 1.

# Пример 2:
# Входные данные: s = "10"
# Результат: 1
# Пояснение: "10" соответствует десятичному числу 2.
# Шаг 1) 2 - четное, делим на 2 и получаем 1.

# Пример 3:
# Входные данные: s = "1"
# Результат: 0

# Ограничения:
# Длина строки s от 1 до 500 символов.
# Строка s состоит только из символов '0' или '1'.
# Первый символ строки s всегда равен '1'.

class Solution:
    def numSteps(self, s: str) -> int:

        steps = 0
        carry = 0

        for i in range(len(s) - 1, 0, -1):
            current_bit = int(s[i]) + carry

            if current_bit % 2 == 1:
                steps += 2
                carry = 1
            else:
                steps += 1

        return steps + carry

# Как это работает:

# 1. Мы обрабатываем число справа налево, используя переменную carry
# для отслеживания переноса от операции "+1".

# 2. Для каждого бита (кроме первого):
# - если текущий бит с учётом переноса равен 1 (нечётное):
# - добавляем 2 шага (один на "+1" и один на "/2")
# - устанавливаем перенос в 1, так как добавление 1 к нечётному числу создаёт перенос
# - если текущий бит с учётом переноса равен 0 (чётное):
# - добавляем 1 шаг (только "/2")
# - перенос остаётся прежним

# 3. В конце добавляем оставшийся перенос как дополнительный шаг, если он есть.
# Почему это эффективно?
# Временная сложность: O(n), где n - длина строки.
# Пространственная сложность: O(1), используем только несколько переменных.
# Нет преобразования в целое число, что позволяет обрабатывать очень длинные строки.