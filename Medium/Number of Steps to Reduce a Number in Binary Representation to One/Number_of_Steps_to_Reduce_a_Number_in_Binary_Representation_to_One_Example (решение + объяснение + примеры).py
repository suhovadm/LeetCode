# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Определяем метод numSteps, который принимает в себя ряд параметров.
    # s: str - строка (двоичное представление числа).
    # -> int - возврат целого числа (количество шагов).
    def numSteps(self, s: str) -> int:

        # Заводим переменные.

        # steps - счётчик количества выполненных шагов.
        steps = 0
        # carry - флаг переноса (0 или 1), который возникает при добавлении 1 к нечётному числу.
        carry = 0

        # Заводим цикл for, который проходит по строке справа налево (от младших разрядов
        # к старшим), но останавливается перед первым символом (индекс 0).
        # len(s) - 1 - начинаем с последнего символа.
        # 0 - заканчиваем перед первым символом (не включая его).
        # -1 - движемся справа налево.
        for i in range(len(s) - 1, 0, -1):

        # Вычисляем текущее значение бита с учётом переноса.
        # int(s[i]) - преобразуем символ '0' или '1' в число 0 или 1.
        # прибавляем carry (0 или 1) от предыдущих операций.
            current_bit = int(s[i]) + carry

        # Проверяем, является ли текущее число (с учётом переноса) нечётным.
        # current_bit % 2 - остаток от деления на 2.
        # если остаток равен 1, значит число нечётное.
            if current_bit % 2 == 1:

        # Обрабатываем нечётное число:
        # steps += 2 - добавляем 2 шага:
        # первый шаг - операция "+1" (превращает нечётное число в чётное),
        # второй шаг - операция "/2" (деление чётного числа).
                steps += 2

        # carry = 1 - устанавливаем перенос, так как при добавлении 1 к
        # нечётному числу происходит перенос в следующий разряд.
                carry = 1

        # Обрабатываем чётное число:
        # steps += 1 - добавляем только 1 шаг (операция "/2"),
        # перенос carry остаётся без изменений.
            else:
                steps += 1

        # Возвращаем результат:
        # steps - все шаги, которые мы считали в цикле,
        # + carry - добавляем оставшийся перенос как дополнительный шаг (если carry = 1,
        # то нужно ещё одно деление на 2).
        return steps + carry

# Вывод примеров в консоль.
if __name__ == "__main__":
    solution = Solution()

    # Пример 1.
    s1 = "1101"
    result1 = solution.numSteps(s1)
    print(f'Пример 1: s = \"{s1}\"')
    print(f'Результат: {result1}')
    print(f'Ожидаемый результат: 6')
    print()

    # "1101" (число 13).
    # Считаем справа налево:
    # - шаг с последней цифрой ('1'): нечётное +2 шага, запоминаем перенос.
    # - шаг со второй цифрой ('0'): с учётом переноса = 1 (нечётное) +2 шага, перенос остаётся.
    # - шаг с третьей цифрой ('1'): с учётом переноса = 2 (нечётное) +1 шаг.
    # Итого: 2 + 2 + 1 = 5 шагов в цикле + 1 перенос = 6 шагов.

    # Пример 2.
    s2 = "10"
    result2 = solution.numSteps(s2)
    print(f'Пример 2: s = \"{s2}\"')
    print(f'Результат: {result2}')
    print(f'Ожидаемый результат: 1')
    print()

    # "10" (число 2).
    # Считаем справа налево:
    # Шаг с последней цифрой ('0'): чётное +1 шаг, переноса нет.
    # Итого: 1 шаг в цикле + 0 перенос = 1 шаг.

    # Пример 3.
    s3 = "1"
    result3 = solution.numSteps(s3)
    print(f'Пример 3: s = \"{s3}\"')
    print(f'Результат: {result3}')
    print(f'Ожидаемый результат: 0')
    print()

    # "1" (число 1).
    # Цикл не выполняется (нет цифр справа от первой).
    # Итого: 0 шагов в цикле + 0 перенос = 0 шагов.

# -------------------------------------------------------------------------------------- #

# Коротко:

# Идём по цифрам справа налево (кроме первой).
# Если цифра с учётом переноса нечётная +2 шага и запоминаем перенос.
# Если чётная +1 шаг, перенос не меняем.
# В конце прибавляем оставшийся перенос.