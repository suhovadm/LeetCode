# Дана строка s, найдите длину самой длинной подстроки без повторяющихся символов.

# Пример 1:
# Ввод: s = "abcabcbb"
# Вывод: 3
# Объяснение: ответ - "abc" длиной 3. Отметим, что "bca" и "cab" также являются правильными ответами.

# Пример 2:
# Ввод: s = "bbbbb"
# Вывод: 1
# Объяснение: ответ - "b" диной 1.

# Пример 3:
# Ввод: s = "pwwkew"
# Вывод: 3
# Объяснение: ответ - "wke" длиной 3.
# Обратите внимание, что ответом должна быть именно подстрока, "pwke" - это
# подпоследовательность, а не подстрока.

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод, который будет находить длину самой длинной подстроки.
    # В нашем случае, непрерывной последовательности символов в заданной строке,
    # в которой все символы уникальны и не повторяются.
    # self- стандартный параметр для методов класса в Python, указывает на экземпляр класса.
    # s: str - входная строка, в которой нужно найти самую длинную подстроку без повторов.
    # -> int - возвращаемое значение, целое число, представляющее длину самой длинной подстроки
    # без повторяющихся символов.
    def lengthOfLongestSubsting(self, s: str) -> int:

        # Заводим переменные.
        max_length = 0 # Храним максимальную длину подстроки без повторов.
        start = 0       # Индекс начала текущей подстроки без повторов.
        char_index = {} # Словарь для хранения последнего индекса каждого символа.

        # Заводим цикл. Проходимся по всем символам строки.
        for i, char in enumerate(s):

            # Проверка: встречался ли текущий символ ранее
            # и находится ли он внутри текущей подстроки (индекс >= start).
            # char in char_index - проверяем, видели ли мы этот символ раньше.
            # char_index[char] >= start - проверяем, находится ли последнее вхождение
            # ВНУТРИ текущей подстроки.
            if char in char_index and char_index[char] >= start:
                # Если да, то сдвигаем начало подстроки.
                # Начинаем с символа ПОСЛЕ последнего вхождения этого символа.
                # Сдвигаем начало подстроки ПРАВЕЕ повторяющегося символа.
                # Например, если была подстрока "abc" и мы встретили "a", начинаем с "bca".
                start = char_index[char] + 1

            # Обновляем последнюю позицию текущего символа.
            char_index[char] = i

            # Вычисляем длину текущей подстроки.
            # i - текущая позиция (конец подстроки).
            # start - начало подстроки.
            # +1 - потому что индексы начинаются с 0.
            current_length = i - start + 1

            # Обновляем максимальную длину, если текущая длинее.
            max_length = max(max_length, current_length)

        # Возвращаем результат.
        return max_length

# Алгоритм использует скользящее окно:
# start - левая граница окна (начало подстроки).
# i - правая граница окна (текущая позиция).
# При встрече повторяющегося символа левая граница сдвигается вправо.
# Всегда поддерживается подстрока без повторяющихся символов.
