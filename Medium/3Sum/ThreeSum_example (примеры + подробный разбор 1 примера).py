from ThreeSum import *

# Создаём экземпляр класса, запускаем примеры в консоль.
solution = Solution()

print(solution.threeSum([-1,0,1,2,-1,-4]))
print(solution.threeSum([0,1,1]))
print(solution.threeSum([0,0,0]))

# Разбор первого примера.
# 1. Берём исходный массив:
# nums = [-1, 0, 1, 2, -1, -4]

# 2. Сортируем.
# Без сортировки двухуказательный метод не сработает.
# nums = [-4, -1, -1, 0, 1, 2]

# 3. Фиксируем первый элемент.
# Мы по очереди фиксируем nums[i], а для остальных двух ищем сумму -nums[i].

# i = 0 -> nums[i] = -4
# Ищем пару с суммой +4

# Указатели:
# left = 1 (-1)
# right = 5 (2)

# Проверяем суммы:
# -4 + (-1) + 2 = -3 -> мало -> left++
# -4 + 0 + 2 = -2 -> мало -> left++
# -4 + 1 + 2 = -1 -> мало -> left++

# left == right -> решений нет.

# i = 1 -> nums[i] = -1
# Ищем пару с суммой +1
# left = 2 (-1)
# right = 5 (2)
# -1 + (-1) + 2 = 0 [V]
# Мы нашли тройку [-1, -1, 2]
# Сдвигаем указатели и пропускаем дубликаты.

# left = 3 (0)
# right = 4 (1)
# -1 + 0 +1 = 0 [V]
# Мы нашли тройку [-1, 0, 1]
# Сдвигаем указатели -> left >= right -> конец.

# i = 2 -> nums[i] = -1 (дубликат).
# Пропускаем, потому что уже рассматривали -1. Иначе будут одинаковые тройки.

# i = 3 -> nums[i] = 0
# Ищем пару с суммой 0.

# left = 4 (1)
# right = 5 (2)
# 0 + 1 + 2 = 3 -> слишком много -> right--
# Указатели пересеклись - решений нет.

# i = 4 -> nums[i] = 1
# Число уже положительное, а массив отсортирован.
# Дальше сумма не может быть 0.
# Можно останавливать цикл.

# Итого, мы нашли две уникальные тройки:
# [[-1, -1, 2], [-1, 0, 1]]

# Корректность решения.
# 1. Сортировка массива даёт порядок.
# 2. Два указателя гарантируют перебор всех пар без вложенного цикла.
# 3. Пропуск дубликатов защищает от повторов.
# 4. Сложность O(n²) - оптимально.