# Дан целочисленный массив nums. Верните все тройки [nums[i], nums[j], nums[k]],
# такие что i != j, i != k, и nums[i] + nums[j] + nums[k] == 0.

# Обратите внимание, что набор решений не должен содержать повторяющихся троек.

# Пример 1:
# Ввод: nums = [-1,0,1,2-1,-4]
# Вывод: [[-1,-1,2],[-1,0,1]]
# Объяснение:
# nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0
# nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0
# nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0
# Уникальные тройки: [-1,0,1] и [-1,-1,2]. Первая даёт 0 и вторая даёт 0.
# Порядок вывода и порядок элементов в тройках не имеет значения.

# Пример 2:
# Ввод: nums = [0,1,1]
# Вывод: []
# Объяснение: единственная возможная тройка не даёт в сумме 0.

# Пример 3:
# Ввод: nums = [0,0,0]
# Вывод: [[0,0,0]]
# Объяснение: единственная возможная тройка даёт в сумее 0.

# Ограничения:
# 3 <= nums.length <= 3000
# -10⁵ <= nums[i] <= 10⁵

# Импортируем тип List из модуля typing для аннотаций типов.
# Это помогает понять, что функция возвращает список списков целых чисел.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод threeSum, который принимает в себя ряд параметров.
    # self - ссылка на экземпляр класса (стандарт для методов класса).
    # nums: List[int] - список целых чисел.
    # -> List[List[int]] - возвращаем список списков целых чисел (тройки).
    def threeSum(self, nums: List[int]) -> List[List[int]]:

        # Сортировка массива.
        # Сортируем исходный массив по возрастанию.
        nums.sort()

        # Заводим пустой список result, в который будем добавлять найденные тройки.
        result = []

        # Получаем длину массива.
        # Сохраняем длину массива в переменную n, чтобы не вычислять её по нескольку раз в циклах.
        n = len(nums)

        # Запускаем основной цикл по всем возможным первым элементам тройки.
        # Почему здесь n - 2? Здесь нужно оставить место как минимум для второго (i+1)
        # и третьего (i+2) элементов.
        for i in range(n - 2):

            # Пропускаем дубликаты первого элемента.
            # Если текущий элемент равен предыдущему, мы пропускаем его.
            # Почему i > 0?
            # При i = 0 нет предыдущего элемента (i - 1 был бы -1).
            # Зачем это нужно?
            # Чтобы избежать одинаковых троек, начинающихся с одного и того же числа.
            # Например, в массиве [-1,-1,0,1]
            # Для i = 0 (первый -1) находим тройки.
            # Для i = 1 (второй -1) пропускаем, т.к. он равен предыдущему.
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            # Ранний выход (слишком большая сумма).
            # Смотрим на минимально возможную сумму с текущим элементом i.
            # Поскольку массив отсортирован, nums[i], nums[i+1], nums[i+2] -
            # три минимальных числа, начиная с позиции i.
            # Если их сумма > 0, то сумма любых других троек с этим i будет
            # ещё больше (все остальные числа больше или равны nums[i+2]).
            # Значит, можно завершить весь поиск через break.
            # Например:
            # массив [1,2,3,4,5]
            # при i = 0: 1 + 2 + 3 = 6 > 0 -> дальше не ищем.
            if nums[i] + nums[i + 1] + nums[i + 2] > 0:
                break

            # Пропуск, слишком маленькая сумма.
            # Смотрим на максимально возможную сумму с текущим элементом i.
            # nums[n-2] и nums[n-1] - два самых больших числа в массиве.
            # Если их сумма с nums[i] < 0, то даже с самым большими числами сумма отрицательна.
            # Значит, для этого i тройки не существует, но возможно существует для большего i,
            # поэтому просто переходим к следующей итерации, т.е. continue.
            # Например:
            # массив [-5, -4, -3, 0, 1]
            # При i = 0: -5 + 0 + 1 = -4 < 0 -> переходим к следующему i.
            if nums[i] + nums[n - 2] + nums[n - 1] < 0:
                continue

            # Заводим 2 указателя.
            # left - следующий после i элемент (начало подмассива).
            # right - последний элемент массива.
            # Эти два указателя будут сходиться к центру, проверяя все возможные
            # пары для текущего nums[i].
            left, right = i + 1, n - 1

            # Запускаем цикл с двумя указателями.
            # Пока указатели не встретились, ищем пару, которая с nums[i] даёт сумму 0.
            while left < right:
                # Вычисление суммы. Вычисляем сумму текущей тройки.
                total = nums[i] + nums[left] + nums[right]

            # Управление указателями.
            # Логика управления.
            # Если сумма < 0:
            # сумма слишком мала. Увеличиваем её, сдвигая left вправо (к большим числам,
            # т.к. массив отсортирован).
            # Если сумма > 0:
            # сумма слишком велика. Уменьшаем её, сдвигая right влево (к меньшим числам).
            # Если сумма = 0:
            # нашли нужную строку! Обрабатываем её в блоке else.
                if total < 0:
                    left += 1
                elif total > 0:
                    right -= 1

                # Обработка найденной строки.
                else:
                    # 1. Добавляем тройку в результат.
                    result.append([nums[i], nums[left], nums[right]])

                    # 2. Пропускаем дубликаты для left.
                    # Двигаем left вправо, пока не встретим новое число.
                    # Зачем? Чтобы избежать троек с одинаковыми вторыми элементами.
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1

                    # 3. Пропускаем дубликаты для right.
                    # Двигаем right влево, пока не встретим новое число.
                    # Зачем? Чтобы избежать троек с одинаковыми третьими элементами.
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1

                    # 4. Сдвигаем оба указателя для поиска новых пар.
                    # После пропуска дубликатов сдвигаем оба указателя, чтобы продолжить
                    # поиск других пар для текущего i.
                    left += 1
                    right -= 1

        # Возвращаем список всех найденных уникальных троек.
        return result