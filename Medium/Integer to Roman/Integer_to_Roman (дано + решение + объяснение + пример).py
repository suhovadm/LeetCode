# Задача на конвертацию целых чисел в римские цифры.

# Семь различных символов обозначают римские цифры со следующими значениями.

# Символ	Значение
# I	        1
# V	        5
# X	        10
# L	        50
# C	        100
# D	        500
# M	        1000

# Римские цифры образуются путём добавления преобразований десятичных разрядов
# от старшего к младшему. Преобразование десятичного разряда в римскую цифру
# происходит по следующим правилам:

# 1. Если значение не начинается с 4 или 9, выберите символ с максимальным
# значением, которое можно вычесть из исходного числа, добавьте этот символ
# к результату, вычтите его значение и преобразуйте остаток в римскую цифру.

# 2. Если значение начинается с 4 или 9, используйте вычитательную форму, где
# один символ вычитается из следующего символа, например 4 - это 1 (I) меньше
# 5 (V): IV, а 9 - это 1 (I) меньше 10 (X): IX. Используются только следующие
# вычитательные формы: 4 (IV), 9 (IX), 40 (XL), 90 (XC), 400 (CD) и 900 (CM).

# 3. Только степени 10 (I, X, C, M) могут быть добавлены подряд не более 3 раз
# для обозначения кратных 10. Нельзя добавлять символы 5 (V), 50 (L) или 500 (D)
# несколько раз. Если требуется добавить символ 4 раза, используйте вычитательную форму.

# Задано целое число. Преобразуйте его в римскую цифру.

# Пример 1:
# Ввод: num = 3749
# Вывод: "MMMDCCXLIX"
# Объяснение:
# 3000 = MMM, так как 1000 (M) + 1000 (M) + 1000 (M)
# 700 = DCC, так как 500 (D) + 100 (C) + 100 (C)
# 40 = XL, так как 10 (X) меньше 50 (L)
# 9 = IX, так как 1 (I) меньше 10 (X)
# Примечание: 49 - это не 1 (I) меньше 50 (L), потому что преобразование основано на
# десятичных разрядах.

# Пример 2:
# Ввод: num = 58
# Вывод: "LVIII"
# Объяснение:
# 50 = L
# 8 = VIII

# Пример 3:
# Ввод: num = 1994
# Вывод: "MCMXCIV"
# Объяснение:
# 1000 = M
# 900 = CM
# 90 = XC
# 4 = IV

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод, который принимает в себя ряд параметров.
    # self - это ссылка на экземпляр класса. Он обязателен, даже если нигде не используется.
    # num: int - это аннотация, которая указывает нам, что ожидается целое число (int).
    # -> str - это аннотация возвращаемого значения. Говорит нам о том, что метод возвращает строку (str).
    def intToRoman(self, num: int) -> str:

        # Заводим карту для конвертации чисел в символы.
        # Внутри карты список кортежей. Список отсортирован по убыванию.
        roman_map = [
            (1000, "M"),
            (900, "CM"),
            (500, "D"),
            (400, "CD"),
            (100, "C"),
            (90, "XC"),
            (50, "L"),
            (40, "XL"),
            (10, "X"),
            (9, "IX"),
            (5, "V"),
            (4, "IV"),
            (1, "I")
        ]

        # Создаём пустой список для вывода результата.
        # В этот список будут добавляться результаты с помощью .append-a.
        # В последствии, список будет преобразован в строку.
        result = []

        # Алгоритм конвертации.
        # Заводим цикл for. Он перебирает все элементы списка roman_map.
        # На каждой итерации из кортежа извлекаются два значения: value (1000) и symbol ("M").
        # Итерации идут строго в том порядке, в котором элементы расположены в списке. Сверху вниз.
        for value, symbol in roman_map:

            # Внутри цикла for запускаем вложенный цикл while.
            # Условие: пока наше текущее число num больше или равно значению value из текущей пары.
            # Смысл: Этот цикл отвечает на вопрос: "Сколько раз текущий римский символ помещается в остатке числа?"
            # Например, для числа 3500 и значения 1000, условие 3500 >= 1000 будет истинным 3 раза.
            while num >= value:

                # Если условие while истинно, мы добавляем append соответствующий
                # римский символ в конец списка result.
                # Для примера с 3500: здесь "М" добавится три раза подряд.
                result.append(symbol)

                # После добавления символа мы вычитаем его арабское значение (value) из
                # текущего числа num.
                # Цель: уменьшить исходное число на ту часть, которую мы уже перевели в римскую запись.
                # Для примера с 3500: после первого прохода num станет 2500 (3500-1000), после
                # второго - 1500, после третьего - 500. Когда num станет 500, условие 500 >= 1000
                # станет ложным и цикл while для пары (1000, "M") завершится.
                num -= value

        # После того как внешний цикл for полностью перебрал весь список roman_map и число num
        # стало равным 0, мы выходим из цикла.
        # "".join(result) - это эффективный метод преобразования списка строк в одну строку.
        # "" - это строка-разделитель (в нашем случае - пустая строка, т.к. символы нужно склеить без пробелов).
        # .join() - метод, который берет все элементы списка result и соединяе из в одну строку,
        # используя указанный разделитель.
        # return - завершает работу метода и возвращает полученную строку.
        return "".join(result)

if __name__ == "__main__":
    solution = Solution()
    example_num = 1994
    roman_result = solution.intToRoman(example_num)
    print(f'\nЧисло {example_num} в римской системе счисления: {roman_result}')
    print('\nДемонстрация работы алгоритма для 1994:')
    print('1. 1994 >= 1000 -> True: добавляем "M", остаётся 994')
    print('2. 994 >= 900 -> True: добавляем "CM", остаётся 94')
    print('3. 94 >= 90 -> True: добавляем "XC", остаётся 4')
    print('4. 4 >= 4 -> True: добавляем "IV", остаётся 0')
    print(f'Результат: "M" + "CM" + "XC" + "IV" = "{roman_result}"')