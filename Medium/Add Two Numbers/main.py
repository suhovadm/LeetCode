# Нам даны два непустых связанных списка, представляющих два неотрицательных целых числа.
# Цифры хранятся в обратном порядке, и каждый узел содержит одну цифру. Сложите два числа
# и верните сумму в виде связанного списка.

# Можно считать, что в числах нет ведущих нулей, за исключением самого числа 0.

# Пример 1:
# Вход: l1 = [2,4,3], l2 = [5,6,4]
# Выход: [7,0,8]
# Объяснение: 342 + 465 = 807

# Пример 2:
# Вход: l2 = [0], l2 [0]
# Выход: [0]

# Пример 3:
# Вход: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
# Выход: [8,9,9,9,0,0,0,1]

# Часть 1. Основная логика работы программы.

# Данный класс LeetCode не принимает. Его в решении на самом LeetCode прописывать НЕ НАДО.
# Это класс для создания узлов связанного списка.
# Его надо определить в обоих файлах, чтобы не было ошибок при выводе.

# Создаём шаблон (класс) для звена цепочки (узла списка).
class ListNode:
    def __init__(self, val=0, next=None): # при создании звена:
        self.val = val # сохраняем цифру (значение)
        self.next = next # указываем на следующее звено (если оно есть)

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод addTwoNumbers, который принимает в себя ряд параметров.
    def addTwoNumbers(self, l1, l2):

        # Создаём "пустышку" - начальную точку для ответа.
        dummy = ListNode(0)
        # Указатель, который будет двигаться по нашему ответу.
        current = dummy
        # Это то, что мы переносим на следующий разряд.
        carry = 0

        # Цикл продолжается до тех пор, пока есть хотя бы одна цифра или перенос.
        # То есть, цикл работает до тех пор, пока есть что складывать.
        while l1 or l2 or carry:
            # Берём цифру из первого числа, если она есть, иначе 0.
            val1 = l1.val if l1 else 0
            # Берём цифру из второго числа, если она есть, иначе 0.
            val2 = l2.val if l2 else 0

            # Суммируем: цифра 1 + цифра 2 + перенос с предыдущего разряда.
            total = val1 + val2 + carry

            # Записываем только последнюю цифру.
            digit = total % 10
            # То, что переносим дальше.
            carry = total // 10

            # Создаём новое звено цепочки с нашей цифрой.
            current.next = ListNode(digit)
            # Переходим к этому новому звену.
            current = current.next

            # Если в первом числе ещё есть цифры - идём дальше.
            if l1:
                l1 = l1.next
            # Если во втором числе ещё есть цифры - идём дальше.
            if l2:
                l2 = l2.next

        # Возвращаем ответ, начиная с первого реального звена (пропускаем фиктивный узел).
        return dummy.next

# dummy = ListNode(0) - создаём "крючок", за который будем цеплять ответ.
# current = dummy - указатель, который показывает, куда добавлять следующую цифру.
# carry = 0 - это то, что мы переносим на следующий разряд. Т.е. это то, что мы "держим в уме".

# Цикл работает так:
# берём по одной цифре из каждого числа, складываем их плюс то, что "в уме".
# Записываем только последнюю цифру (например, из 12 берём 2).
# А первую цифру (из 12 берём 1) переносим дальше.
# Добавляем цифру в ответ.
# Затем переходим к следующим цифрам в числах.

# Складываем 342 + 465 в столбик:
# 342
# + 465
# -------------
# Получаем: 807

# Пошагово (с конца):
# 2 + 5 = 7     (записываем 7, "в уме" 0)
# 4 + 6 = 10    (записываем 0, "в уме" 1)
# 3 + 4 + 1 = 8 (записываем 8, "в уме" 0)

# Получаем 7 - 0 - 8 (это 807

# Мы возвращаем dummy.next, потому что первый узел dummy - это просто "крючок",
# а реальный ответ начинается со следующего узла.