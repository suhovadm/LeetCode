# Дан массив целых чисел nums длины n и целое число target.
# Найдите три целых числа на различных позициях в массиве nums,
# сумма которых наиболее близка к target.

# Верните сумму этих трёх чисел.

# Можно считать, что для каждого входного набора данных существует ровно одно решение.

# Пример 1:
# Ввод: nums = [-1, 2, 1, -4], target = 1
# Вывод: 2
# Объяснение: сумма, наиболее близкая к цели: 2 (-1 + 2 + 1 = 2).

# Пример 2:
# Ввод: nums = [0, 0, 0], target = 1
# Вывод: 0
# Объяснение: сумма, наиболее близкая к цели: (0 + 0 + 0 = 0).

# Ограничения:
# 3 <= nums.length <= 500
# -1000 <= nums[i] <= 1000
# -10⁴ <= target <= 10⁴

# Импортируем List из модуля typing для поддержки аннотации типов.
# Это говорит нам о том, что функция принимает и возвращает списки целых чисел.
from typing import List

# Заводим класс Solution, как того требует Литкод.
class Solution:
    # Заводим метод threeSumClosest, который принимает в себя ряд параметров.
    # self - ссылка на экземпляр класса (стандартный первый параметр методов класса).
    # nums: List[int] - список целых чисел.
    # target: int - target с типом "целое число".
    # -> int - возвращаемое значение - целое число.
    def threeSumClosest(self, nums: List[int], target: int) -> int:

        # Сортируем массив.
        nums.sort()

        # Инициализация ближайшей суммы.
        # nums[0], nums[1], nums[2] - первые три элемента отсортированного массива.
        # Пример: для [-4, -1, 1, 2]: closest = -4 + (-1) + 1 = -4
        # Альтернатива: можно было бы использовать float('inf') как было в первом варианте,
        # но это создаёт проблемы при сравнении модулей разности. Т.е. проблемы при выводе!
        closest = nums[0] + nums[1] + nums[2]

        # Заводим основной внешний цикл.
        # range(len(nums) - 2) - создаёт диапазон от 0 до len(nums) - 3) включительно.
        # len(nums) - 2 - ограничение, т.к. нужно минимум 3 элемента для суммы.
        # i - индекс первого элемента тройки.
        # Итерации: для массива из 4 элементов i примет значения 0, 1
        # Пример: nums = [-4, -1, 1, 2] -> range(2) -> i = 0, 1
        # В данном случае произойдёт перебор всех возможных элементов тройки.
        for i in range(len(nums) - 2):

            # Заводим указатели.
            # left = i + 1 - левый указатель начинается сразу после i.
            # right = len(nums) - 1 - правый указатель начинается с последнего элемента.
            # Пример: при i = 0, left = 1, right = 3 (для массива из 4 элементов).
            # Зачем это нужно? Так мы определяем диапазон для поиска оставшихся двух
            # элементов тройки.
            left, right = i + 1, len(nums) - 1

            # Внутренний цикл с двумя указателями.
            # Условие: left < right гарантирует, что мы рассматриваем разные элементы.
            # Работа цикла продолжается, пока указатели не встретятся или не пересекутся.
            # Зачем это нужно? Поиск оптимальной пары для фиксированного первого элемента.
            while left < right:
                # Вычисление текущей суммы.
                # nums[i] - фиксированный первый элемент тройки.
                # nums[left] - текущий левый элемент.
                # nums[right] - текущий правый элемент.
                # Пример: при i = 0, left = 1, right = 3: total = -4 + (-1) + 2 = -3.
                # Что мы получаем? Вычисление суммы для текущей комбинации.
                total = nums[i] + nums[left] + nums[right]

                # Проверка точного совпадения.
                # total == target - проверка равенства суммы и цели.
                # return total - немедленный возврат результата при точном совпадении.
                # Что это нам даёт? Ранний выход при нахождении идеального решения.
                # + Сэкономит время, если найдётся точное совпадение.
                if total == target:
                    return total

                # Обновление ближайшей суммы.
                # abs(total - target) - абсолютное отклонение текущей суммы от цели.
                # abs(closest - target) - абсолютное отклонение лучшей найденной суммы от цели.
                # closest присваивается значение total.
                # Пример: если target= 1, closest= -4 (отклонение 5), total= 2 (отклонение 1) ->
                # closest обновится до 2.
                # Зачем это нужно? Поддержание наиболее близкой к цели суммы.
                if abs(total - target) < abs(closest - target):
                    closest = total

                # Движение указателей.
                # total < target - если сумма меньше цели.
                # left += 1 - увеличиваем левый указатель (сумма увеличивается, т.к. массив отсортирован).
                # total >= target - если сумма больше или равна цели.
                # right -= 1 - уменьшаем правый указатель (сумма уменьшается).
                # Логика данной части: используем свойство отсортированного массива для приближения к цели.
                # Пример: если total= -3, target= 1 -> total < target -> left += 1.
                if total < target:
                    left += 1
                else:
                    right -= 1

        # Возвращает наиболее близкую к цели сумму.
        return closest