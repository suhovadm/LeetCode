# Первый вариант решения. Быстрый и сложный.

# Дана строка s. Верните самую длинную подстроку-палиндром в s.

# Пример 1:
# Ввод: s = "babad"
# Ввод: "bab"
# Пояснение: "aba" также является допустимым ответом.

# Пример 2:
# Ввод: s = "cbbd"
# Вывод: "bb"

# Ограничения:
# 1 <= s.length <= 1000
# s состоит только из цифр и английского алфавита.

# Заводим класс Solution, как того требует LeetCode.
class Solution:

    # Заводим метод longestPalindrome, который принимает в себя ряд параметров.
    # self - ссылка на экземпляр класса (обязательный первый параметр для методов класса).
    # s: str - входной параметр s с указанием типа строка.
    # Это аннотация типа, она подсказывает, какой тип ожидается.
    # -> str: - аннотация типа возвращаемого значения. Указывает, что мы возвращаем строку str.
    # Т.е. данный метод принимает строку s и возвращает самую длинную подстроку из s, которая является
    # палиндромом.
    def longestPalindrome(self, s: str) -> str:

        # Вложенная функция (подметод).
        # Её задача - найти максимальный палиндром, центр которого находится между индексами left и right.
        # Она принимает в себя два индекса и возвращает палиндром как строку.
        def expand_around_center(left: int, right: int) -> str:

            # Начинаем цикл while.
            # left >= 0 - левый указатель не вышел за границу строки (влево от начала).
            # right < len(s) - правый указатель не вышел за границу строки (вправо от конца).
            # s[left] == s[right] - символы на позициях left и right совпадают.
            # Цикл будет "расширяться" в обе стороны, пока выполняются все три условия.
            while left >= 0 and right < len(s) and s[left] == s[right]:

                # Если символы совпали и границы не достигнуты, "расширяем" область проверки: сдвигаем
                # левый указатель на одну позицию влево, а правый - на одну позицию вправо.
                left -= 1
                right += 1

            # Когда цикл завершился (символы перестали совпадать или достигли границ), возвращаем
            # найденную подстроку-палиндром.
            # Почему left + 1 и right? На последней итерации цикла, когда символы совпали, мы сдвинули
            # left и right (left -= 1, right += 1. После этого условие цикла нарушилось. Значит,
            # последние действительные индексы, где символы совпадали и были в границах, - это:
            # left + 1, right - 1.
            # s[left + 1:right] - это срез строки, который включает все символы от left + 1 до right - 1
            # включительно. Синтаксис среза [start:end] в Python берёт элементы от start до end,
            # не включает сам end.
            return s[left + 1:right]

        # Обработка простого случая.
        # Если длина входной строки 0 или 1 символа, то она сама по себе является палиндромом.
        # Возвращаем её сразу. Это также база для рекурсивного/итеративного подхода и защита от ошибок.
        if len(s) <= 1:
            return s

        # Заводим переменную для результата.
        # Создаём переменную longest, в которой будем хранить самый длинный найденный
        # на данный момент палиндром. Это пустая строка.
        longest = ""

        # Основной цикл и логика поиска.
        # Запускаем основной цикл, который проходит по каждому индексу i строки s.
        # Индекс i рассматривается как потенциальный центр палиндрома.
        for i in range(len(s)):

            # Ищем палиндром нечётной длины. Для этого в функцию expand_around_center передаём
            # одинаковые значения i и i. Это означает, что центр палиндрома - ровно один символ s[i].
            # Функция будет расширяться влево и вправо от этого центра.
            # Пример для s = "babad", i=2 (символ 'b'):
            # Начинаем с (left=2, right=2). 'b' == 'b'.
            # Расширяемся (left=1, right=3). 'a' == 'a'.
            # Расширяемся (left=0, right=4). 'b' == 'd' ? Нет.
            # Возвращаемся срез s[1:4], т.е. "aba".
            odd_palindrome = expand_around_center(i, i)

            # Ищем палиндром четной длины. Для этого в функцию передаём i и i+1. Это означает, что центр
            # палиндрома находится между двумя символами s[i] и s[i+1]. Функция будет проверять их на
            # совпадение и расширяться.
            # Пример для s = "babad", i=1 (символ 'a'):
            # Начинаем c (left=1, right=2). 'a' == 'b'? Нет. Цикл не выполнится ни разу.
            # Возвращаем срез s[2:2], т.е. пустую строку "".
            even_palindrome = expand_around_center(i, i + 1)

            # Здесь мы определяем, какая из двух найденных для центра i палиндромов длиннее:
            # odd_palindrome или even_palindrome. Результат сохраняем в current_longest. Используется
            # тернарный оператор (x if condition else y).
            current_longest = odd_palindrome if len(odd_palindrome) > len(even_palindrome) else even_palindrome

            # Сравниваем длину только что найденного самого длинного палиндрома для центра i (
            # current_longest) с глобально самым длинным (longest). Если current_longest оказался длиннее,
            # обновляем переменную longest.
            if len(current_longest) > len(longest):
                longest = current_longest

        # Возвращаем результат.
        return longest

# Создаём экземпляр класса и выводим результаты в консоль.
sol = Solution()

print(sol.longestPalindrome("babad"))
print(sol.longestPalindrome("cbbd"))
print(sol.longestPalindrome("a"))
print(sol.longestPalindrome("ac"))
print(sol.longestPalindrome("racecar"))
print(sol.longestPalindrome("abacdfgdcaba"))
print(sol.longestPalindrome("aaaabbaa"))
print(sol.longestPalindrome("forgeeksskeegfor"))

# Краткий итог алгоритма:
# Это алгоритм "Expand Around Center". Вместо перебора всех подстрок
# (что было бы O(n³) или O(n²) с проверкой), он использует идею, что у любого палиндрома есть центр.

# Алгоритм:
# Проходит по каждому символу строки, считая его потенциальным центром.
# Для каждого центра пытается "расширить" палиндром в обе стороны, насколько это возможно.
# Делает это дважды: для палиндромов нечетной длины (центр — символ) и четной длины (центр — между символами).
# Запоминает самый длинный найденный вариант.
# Сложность алгоритма: O(n²) по времени (один внешний цикл по n элементам,
# внутри два расширения, каждое за O(n) в худшем случае). O(1) по памяти
# (используются только переменные для индексов и хранения результата).

# Этот алгоритм хорошо работает для строк до 1000 символов, как указано в ограничениях задачи.
