# Второй вариант решения. Простой, но медленный.

# Дана строка s. Верните самую длинную подстроку-палиндром в s.

# Пример 1:
# Ввод: s = "babad"
# Ввод: "bab"
# Пояснение: "aba" также является допустимым ответом.

# Пример 2:
# Ввод: s = "cbbd"
# Вывод: "bb"

# Ограничения:
# 1 <= s.length <= 1000
# s состоит только из цифр и английского алфавита.

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод longestPalindrome, который принимает в себя ряд параметров.
    # Метод принимает в себя строку s и возвращает самый длинный палиндром как строку.
    def longestPalindrome(self, s: str) -> str:

        # Проверка базового случая:
        # если строка пустая или содержит всего 1 символ,
        # то она сама по себе является палиндромом.
        # Пример: "" -> "", "a" -> "a".
        if len(s) <= 1:
            return s

        # Инициализация переменной для хранения самого длинного найденного палиндрома.
        # Начинаем с первого символа, т.к. строка минимум из 2 символов (из предыдущей проверки)
        # и одиночный символ всегда палиндром.
        # Пример: для "abc" longest = "a".
        longest = s[0]

        # Первый цикл: перебираем ВСЕ возможные начальные индексы подстрок.
        # i - индекс начала подстроки (от 0 до len(s)-1)
        # Пример: для "abc" i будет 0, 1, 2.
        for i in range(len(s)):

            # Второй цикл: перебираем ВСЕ возможные конечные индексы подстрок.
            # j - индекс конца подстроки (НЕ включается в срез).
            # j начинается с i+1, потому что подстрока минимум из 1 символа.
            # j идет до len(s) включительно, так как срез [i:j] не включает j.
            # Пример: для i=0, j будет 1, 2, 3 (для строки "abc" длиной 3).
            for j in range(i + 1, len(s) + 1):

                # Извлекаем подстроку от i до j-1.
                # Пример: s="abc", i=0, j=2 -> substr="ab"
                #         s="abc", i=1, j=3 -> substr="bc"
                substr = s[i:j]

                # Проверяем, является ли подстрока палиндромом.
                # substr[::-1] создаёт перевёрнутую копию строки.
                # Дальше идёт полное сравнение строк.
                # Пример: "aba" == "aba"[::-1] -> "aba" == "aba" -> True
                #         "abc" == "abc"[::-1] -> "abc" == "cba" -> False
                if substr == substr[::-1]:

                    # Если нашли палиндром, проверяем, длиннее ли он текущего.
                    # Сравниваем длины строк.
                    # Пример: если longest="a" (длина 1), а substr="aa" (длина 2),
                    # то условие выполнится.
                    if len(substr) > len(longest):

                        # Обновляем самый длинный палиндром.
                        # Теперь longest содержит новую, более длинную подстроку-палиндром.
                        longest = substr

        # После завершения всех циклов возвращаем найденный самый длинный палиндром.
        # Все возможные подстроки были проверены.
        return longest

# Точка входа в программу.
if __name__ == "__main__":

    # Создаём экземпляр класса и выводим результаты в консоль.
    solution = Solution()

    test_case = [
        "babad",
        "cbbd",
        "a",
        "ac",
        "racecar",
        "abcba",
        "abb",
        "aaaa"
    ]

    # test_case - это список тестовых строк.
    # enumerate(test_case, 1) - проходит по всем тестовым строкам, начиная с 1-й.
    # i - номер примера (1, 2, 3, ...)
    # test - текущая тестовая строка (например, "babad").
    for i, test in enumerate(test_case, 1):

        # Вызываем наш метод для поиска самого длинного палиндрома.
        result = solution.longestPalindrome(test)

        # Выводим информацию о тесте.
        print(f'Пример {i}:')
        print(f'Входная строка: {test}')
        print(f'Найденный палиндром: {result}')
        print(f'Длина: {len(result)}')
        print("-" * 40)

# Как это работает:
# Берём все возможные подстроки: от s[0:1] до s[0:n], затем s[1:2] до s[1:n] и так далее.
# Для каждой подстроки проверяем, равна ли она своему перевёрнутому варианту (палиндром).
# Запоминаем самую длинную палиндромную подстроку.

# Пример:
# Для "babad":
# Проверяем "b", "ba", "bab", "baba", "babad"
# Затем "a", "ab", "aba", "abad"
# И так далее...
# Находим "bab" или "aba"

# Плюсы этого подхода:
# Очень простой для понимания
# Всего 9 строк кода
# Использует встроенную функцию [::-1] для разворота строки
# Минусы:
# Медленный для длинных строк (O(n³)), но для 1000 символов из ограничений задачи будет работать.
