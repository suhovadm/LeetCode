# Перестановка массива целых чисел — это расположение его элементов
# в виде последовательности или линейного порядка.

# Например, для массива arr = [1,2,3] все перестановки выглядят так:
# [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1].
# Следующая перестановка массива целых чисел — это следующая лексикографически
# большая перестановка его целых чисел. Если более формально, когда все перестановки
# массива отсортированы в одном контейнере в соответствии с их лексикографическим порядком,
# то следующей перестановкой данного массива будет та, которая следует за
# ней в отсортированном контейнере. Если такое расположение невозможно, массив
# должен быть преобразован в порядок, который считается наименьшим из возможных
# (т.е. отсортирован по возрастанию).

# Например, следующая перестановка для массива arr = [1,2,3] — это [1,3,2].
# Аналогично, следующая перестановка для arr = [2,3,1] — это [3,1,2].
# В то время как для arr = [3,2,1] следующей перестановкой будет [1,2,3], потому что [3,2,1]
# не имеет лексикографически большего варианта расположения.
# Дан массив целых чисел nums, необходимо найти его следующую перестановку.

# Замена должна производиться на месте (in place) и использовать только константную дополнительную память.

# Пример 1:
# Входные данные: nums = [1,2,3]
# Выходные данные: [1,3,2]

# Пример 2:
# Входные данные: nums = [3,2,1]
# Выходные данные: [1,2,3]

# Пример 3:
# Входные данные: nums = [1,1,5]
# Выходные данные: [1,5,1]

# Ограничения:
# 1 <= nums.length <= 100
# 0 <= nums[i] <= 100

# Импортируем тип List из модуля typing.
# Это нужно для аннотации типов, чтобы указать,
# что метод принимает список целых чисел.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод nextPermutation, который принимает ряд параметров.
    # Метод принимает список целых чисел nums и ничего не возвращает (-> None).
    # Исходный список изменяется на месте.
    def nextPermutation(self, nums: List[int]) -> None:

        # Устанавливаем указатель i на предпоследний элемент списка (индекс len(nums) - 2).
        # Здесь мы начинаем сравнивать пары элементов с конца массива.
        i = len(nums) - 2

        # Первый проход (поиск точки спада):
        # двигаемся справа налево, пока текущий элемент больше или равен следующему.
        # Цель - найти первый элемент, который нарушает возрастающую последовательность с конца.
        # По сути, мы ищем элемент, который меньше своего правого соседа. Индекс i остановится
        # на позиции, где nums[i] < nums[i+1]. Если весь массив идёт по убыванию (например,
        # [3, 2, 1] ), цикл дойдёт до i = -1.
        while i >= 0 and nums[i] >= nums[i + 1]:
            i -= 1

        # Проверяем, нашёлся ли такой элемент. Если i >= 0, значит, мы нашли элемент, который
        # можно увеличить для получения следующего лексикографической перестановки. Если i = -1
        # (весь массив по убыванию), этот блок не выполнится.
        if i >= 0:

            # Второй проход (поиск элемента для замены):
            # устанавливаем указатель j на самый правый элемент. Двигаемся справа налево, пока
            # не найдём первый элемент, который больше nums[i]. Этот элемент гарантированно
            # найдётся, т.к. правее i элементы идут по убыванию и nums[i] < nums[i+1].
            j = len(nums) - 1
            while j >= 0 and nums[j] <= nums[i]:
                j -= 1

            # Замена (Swap):
            # меняем местами элементы на позициях i и j. Теперь в позиции i стоит следующее
            # по величине число, что делает перестановку больше исходной, но ещё не окончательной.
            nums[i], nums[j] = nums[j], nums[i]

        # Реверс суффикса.
        # Эта часть выполняется в любом случае (и когда был i >= 0, и когда i = -1).
        # Устанавливаем left на первый элемент после позиции i, а right на последний элемент.
        # Затем разворачиваем этот отрезок, меняя местами крайние элементы и двигаясь к центру.
        # ! Если мы делали замену (блок if >= 0), то элементы справа от i по-прежнему идут по
        # убыванию. Разворот делает их идущими по возрастанию, что даёт минимально возможный хвост.
        # ! Если i = -1 (весь массив был максимальным, например, [3,2,1], то left = 0, и мы
        # просто переворачиваем весь массив, получая минимальную перестановку [1,2,3].
        left = i + 1
        right = len(nums) - 1
        while left < right:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
            right -= 1

# Пример работы для nums = [1, 2, 3]:
# 1. Поиск i: i = 1 (число 2). 2 >= 3? Нет, цикл останавливается. i = 1.
# 2. Блок if: i >= 0 (1 >= 0) - True.
# Поиск j: j = 2 (число 3). 3 <= 2? Нет, цикл останавливается. j = 2.
# Swap: меняем nums[1] и nums[2]. Получаем [1, 3, 2].
# 3. Реверс: left = i + 1 = 2, right = 2. Условие left < right (2 < 2) - False, реверс не нужен.
# 4. Результат: [1, 3, 2], [V] - ПРАВИЛЬНО!

# Пример работы для nums = [3, 2, 1]:
# 1. Поиск i: i = 1 (число 2). 2 >= 1? Да ---> i = 0. 3 >= 2? Да ---> i = -1. Цикл завершён. i = -1.
# 2. Блок if: i >= 0? (-1 >= 0) - False. Пропускаем Swap.
# 3. Реверс: left = i + 1 = 0, right = 2. Реверсируем весь список: [3, 2, 1] ---> [1, 2, 3].
# 4. Результат: [1, 2, 3], [V] МИНИМАЛЬНАЯ ПЕРЕСТАНОВКА ПОСЛЕ МАКСИМАЛЬНОЙ.