# Generate Parentheses.

# Дано n пар строк, напишите функцию для генерации всех комбинаций правильных
# скобочных последовательностей.

# Пример 1:
# Ввод: n = 3
# Вывод: ["((()))","(()())","(())()","()(())","()()()"]

# Пример 2:
# Ввод: n = 1
# Ввод: ["()"]

# Ограничения:
# 1 <= n <= 8

# Импортируем тип List из модуля typing.
# Это нужно для аннотации типа возвращаемого значения функции, чтобы указать,
# что метод возвращает список строк.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод внутри класса.
    # self - ссылка на экземпляр класса. Обязательный первый параметр
    # для методов класса в Python.
    # n: int - параметр n с аннотацией int, т.е. ожидается целое число.
    # -> List[str] аннотация возвращаемого типа: метод должен вернуть список строк в str.
    def generateParenthesis(self, n: int) -> List[str]:

        # Создаём пустой список.
        # В этот список будем добавлять все найденные правильные скобочные последовательности.
        result = []

        # Заводим вложенную функцию backtrack.
        # Это рекурсивная функция, которая будет строить бесконечные скобочные последовательности.
        # current: str - текущая строка, которую мы строим.
        # open_count: int - кол-во открывающих скобок "(", уже добавленных в current.
        # close_count: int - кол-во закрывающих скобок ")", уже добавленных в current.
        def backtrack(current: str, open_count: int, close_count: int):

            # Условие выхода.
            # if len(current) == 2 * n - проверяем, достигла ли текущая строка максимальной длины.
            # Так как у нас n пар строк, то общая длина правильной последовательности должна быть 2 * n.
            if len(current) == 2 * n:

                # result.append(current) - если длина достигнута, добавляем текущую строку в список результов.
                result.append(current)
                # выходим из текущего вызова функции, т.е. прекращаем углубляться по этой ветке рекурсии.
                return

            # Рекурсивный шаг для открывающей скобки.
            # Проверяем, можем ли мы добавить ещё одну открывающую скобку.
            # Мы не можем добавить больше, чем n открывающих скобок.
            if open_count < n:
                # Если можем, вызываем backtrack рекурсивно:
                # добавляем к текущей строке "(".
                # Увеличиваем счётчик открывающих скобок на 1.
                # Счётчик закрывающих скобок остаётся без изменений.
                backtrack(current + "(", open_count +1, close_count)

            # Рекурсивный шаг для закрывающей скобки.
            # Проверяем, можем ли мы добавить закрывающую скобку.
            # Мы можем добавить закрывающую скобку только тогда,
            # когда закрывающих скобок меньше, чем открывающих.
            # Это гарантирует, что у каждой закрывающей скобки будет
            # соответствующая открывающая скобка слева.
            if close_count < open_count:
                # Вызываем backtrack, добавляем к текущей строке ")".
                # Счётчик открывающих скобок остаётся без изменений.
                # Увеличиваем счётчик закрывающих скобок на 1.
                backtrack(current + ")", open_count, close_count +1)

        # Начальный вызов рекурсивной функции. Мы вызываем backtrack с начальными параметрами.
        # current = "" - начинаем с пустой строки.
        # open_count = 0 - пока нет открывающих скобок.
        # close_count = 0 - пока нет закрывающих скобок.
        # Это запустит весь процесс рекурсии.
        backtrack("", 0, 0)

        # После того как рекурсия завершится, метод возвращает список result.
        return result