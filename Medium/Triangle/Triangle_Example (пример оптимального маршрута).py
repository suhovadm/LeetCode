from Triangle import *

# Пример использования:
triangle_example = [
    [2],
    [3, 4],
    [6, 5, 7],
    [4, 1, 8, 3]
]

# Создаём экземпляр класса Solution.
# solution - это объект, через который мы можем вызывать метод minimumTotal.
solution = Solution()

# Вызываем метод minimumTotal у объекта solution.
# Передаём ему треугольник triangle_example.
# Метод возвращает минимальную сумму пути через треугольник.
# Результат сохраняется в переменную result.
result = solution.minimumTotal(triangle_example)

# Выводим пример в консоль.
print('Минимальная сумма пути:', result)

# Сам треугольник:
#       2
#      3 4
#     6 5 7
#    4 1 8 3

# Самый дешёвый маршрут:
#       2
#      ↓
#       3
#      ↓
#       5
#      ↓
#       1

# Минимальный путь идёт так:
# 1. Берём 2 (верхушка)
# 2. Потом 3 (спускаемся к меньшему из 3 и 4 в следующем ряду)
# 3. Потом 5 (спускаемся к меньшему из 6 и 5)
# 4. Потом 1 (спускаемся к меньшему из 4 и 1)
# То есть путь: 2 -> 3 -> 5 -> 1
# Сумма: 2 + 3 + 5 + 1 = 11

# Почему сумма идёт именно вот так: 2 + 3 + 5 + 1 = 11?
# Почему не так, например: 2 + 3 + 6 + 4?
# Потому что задача - найти МИНИМАЛЬНУЮ сумму пути.
# Алгоритм на каждом шаге выбирает меньшее из двух возможных чисел снизу.
# Т.е. мы не просто идём слева, мы каждый раз выбираем более дешёвый путь
# снизу, потому что алгоритм идёт снизу вверх и заранее знает минимальные суммы.
# 2 + 3 + 5 + 1 = 11 [V]
# 2 + 3 + 6 + 4 = 15 [X]
# 11 меньше 15, значит 11 выгоднее чем 15. Оно меньше, а значит быстрее, ну или "дешевле".