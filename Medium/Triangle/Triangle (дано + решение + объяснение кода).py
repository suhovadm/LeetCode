# Triangle.

# Дано.

# Учитывая треугольный массив, верните минимальную сумму пути сверху вниз.

# На каждом шаге вы можете переместиться на соседнее число в строке ниже.
# Более формально, если вы находитесь на индексе i в текущей строке, вы
# можете перейти либо на индекс i, либо на индекс i + 1 в следующей строке.

# Пример 1:
# Входные данные: треугольник = [[2],[3,4],[6,5,7],[4,1,8,3]]
# Выходные данные: 11
# Пояснение: треугольник выглядит так:
# 2
# 3 4
# 6 5 7
# 4 1 8 3
# Минимальная сумма пути сверху вниз равна 2 + 3 + 5 + 1 = 11 (выделено подчёркиванием выше).

# Пример 2:
# Входные данные: треугольник = [[-10]]
# Выходные данные: -10

# Ограничения:
# 1 <= длина треугольника <= 200
# длина треугольника[0] == 1
# длина треугольника[i] == длина треугольника[i - 1] + 1
# -10⁴ <= треугольник[i][j] <= 10⁴

# Импортируем тип List из модуля typing для аннотации типов.
# Это позволяет указать, что функция принимает список списков целых чисел.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Определяем метод minimumTotal, который принимает в себя ряд параметров.
    # self - ссылка на экземпляр класса.
    # triangle - треугольный массив (список списков целых чисел).
    # -> int - возвращает целое число (минимальную сумму пути).
    def minimumTotal(self, triangle: List[List[int]]) -> int:

    # Если треугольник пустой, возвращаем 0.
    # Это защита от некорректных входных данных.
        if not triangle:
            return 0

    # Создаём копию последней строки треугольника:
    # triangle[-1] обращается к последнему элементу (последней строке) списка.
    # [:] создаёт полную копию этой строки.
    # Этот массив будет хранить минимальные суммы путей для текущего уровня обработки.
        dp = triangle[-1][:]

    # Внешний цикл проходит по строкам снизу вверх, начиная с предпоследней строки:
    # len(triangle) - 2 - индекс предпоследней строки,
    # -1 (стоп) - доходим до индекса 0 включительно,
    # -1 (шаг) - движемся в обратном направлении.
        for i in range(len(triangle) - 2, -1, -1):

    # Внутренний цикл проходит по всем элементам текущей строки:
    # len(triangle[i]) - длина текущей строки,
    # j - индекс текущего элемента в строке.
            for j in range(len(triangle[i])):

    # triangle[i][j] - значение текущего элемента,
    # dp[j] и dp[j + 1] - минимальные пути от двух возможных элементов снизу,
    # min(dp[j], dp[j + 1] - выбираем минимальный путь из двух вариантов.
    # Складываем текущее значение с минимальным путём снизу.
    # Сохраняем результат в dp[j] (перезаписываем старое значение).
                dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])

    # После завершения всех циклов в dp[0] хранится минимальная сумма пути
    # от вершины до низа. Возвращаем это значение.
        return dp[0]