# Валидный IP адрес состоит ровно из четырёх целых чисел, разделённых точками.
# Каждое число находится в диапазоне от 0 до 255 (включительно) и не может
# иметь ведущих нулей.

# Например "0.1.2.201" и "192.168.1.1" являются валидными IP адресами, а "0.011.255.245",
# "192.168.132" и "192.168@1.1" - невалидные IP адреса.

# Дана строка s, содержащая только цифры. Верните все возможные валидные IP адреса, которые
# могут быть сформированы путём вставки точек в s. Вам не разрешено изменять порядок или
# удалять какие-либо цифры в строке s. Вы можете вернуть валидные IP адреса в любом порядке.

# Пример 1:
# Ввод: s = "25525511135"
# Вывод: ["255.255.11.135", "255.255.111.35"]

# Пример 2:
# Ввод: s = "0000"
# Вывод: ["0.0.0.0"]

# Пример 3:
# Ввод: s = "101023"
# Вывод: ["1.0.10.23", "1.0.102.3", "10.1.0.23", "10.10.2.3", "101.0.2.3"]

# Импортируем библиотеку List.
# List - это тип "список", он используется для аннотации возвращаемого значения.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:

    # Заводим метод restoreIpAddresses, который принимает в себя ряд параметров.
    # self - ссылка на экземпляр класса (обязательный первый параметр для методов класса).
    # s: str - параметр s со строковым параметром str.
    # -> List[str] - указывает, что функция возвращает список строк.
    def restoreIpAddresses(self, s: str) -> List[str]:

        # Заводим вывод результата.
        # Создаём пустой список, где будем хранить все найденные ВАЛИДНЫЕ IP адреса.
        result = []

        # Заводим внутреннюю рекурсивную функцию, которая доступна только внутри restoreIpAddresses.
        # Функция использует технику backtracking (поиск с возвратом).
        # Принимает 3 параметра:
        # start - индекс в строке s, с которого начинается текущая часть IP адреса.
        # parts - количество уже сформированных частей IP адреса (от 0 до 4).
        # current - текущий строящийся IP адрес в виде строки.
        def backtrack(start, parts, current):

            # Проверка завершения.
            # Условие: если собрали 4 части и использовали все цифры строки.
            # parts == 4 - собрали все части IP адреса.
            # start == len(s) - дошли до конца строки (все цифры использованы)
            if parts == 4 and start == len(s):

                # current[:-1] - удаляем последнюю точку (".") из текущего адреса.
                # result.append() - добавляем готовый IP адрес в список результатов.
                result.append(current[:-1])
                return # Выходим из рекурсии.

            # Проверка невозможности построить валидный IP-шник.
            # Условие: если собрали 4 части ИЛИ использовали все цифры, но одно из условий не выполняется.
            # Это означает:
            # - или: собрали 4 части, но цифры ещё остались (слишком много цифр).
            # - или: цифры знакончились, но частей меньше 4 (слишком мало цифр).
            if parts == 4 or start == len(s):
                return # Прекращаем дальнейшие поиски по этой ветке.

            # Начинаем перебор возможных длин следующей части.
            # range(1, 4) - создаёт последовательность [1,2,3].
            # Каждая часть IP адреса может содержать от 1 до 3 цифр.
            # Перебираем все возможные длины для следующей части.
            for length in range(1, 4):

                # Проверка выхода за границы строки.
                # Проверяем, что при взятии сегмента длины length начиная с позиции start
                # мы не выйдем за границы строки.
                if start + length > len(s):

                    # Если выходим за границы, пропускаем эту длину и переходим к следующей.
                    continue

                # Извлечение сегмента.
                # s[start:start + length] - это срез строки, получаем подстроку (сегмент) заданной длины.
                # Например, если s = "25525511135", start = 0, length = 3, то segment = "255".
                segment = s[start:start + length]

                # Проверка валидности сегмента.
                # --- Первое условие: (len(segment) > 1 and segment[0] == '0')
                # Проверка на ведущие нули.
                # Если длина сегмента больше 1 и первая цифра равна '0' - это невалидный сегмент.
                # Примеры невалидных: "01", "001", "0.0.01.0".
                # Примеры валидных: "0", "10", "100".
                # --- Второе условие: int(segment) > 255.
                # Преобразуем сегмент в число и проверяем, что оно <= 255.
                # IP адрес не может содержать числа больше 255.
                # Оператор or: если хотя бы одно условие истинно, сегмент невалиден.
                if (len(segment) > 1 and segment[0] == '0') or int(segment) > 255:

                    # Пропускаем этот невалидный сегмент.
                    continue

                # Рекурсивный вызов.
                # Рекурсивно вызываем backtrack с новыми параметрами:
                # start + length - двигаем указатель в строке на длину взятого сегмента.
                # parts + 1 - увеличиваем счётчик частей на 1.
                # current + segment + '.' - добавляем сегмент и точку к текущему адресу.
                # Например: если current = "255.", segment = "255", то новое значение: "255.255."
                backtrack(start + length, parts + 1, current + segment + '.')

        # Начало рекурсии.
        # Запускаем рекурсивный поиск с начальными параметрами.
        # start = 0 - начинаем с первого символа строки.
        # parts = 0 - пока не собрано ни одной части.
        # current = "" - текущий адрес пуст.
        backtrack(0, 0, "")

        # Возвращаем список всех найденных валидных IP адресов.
        return result

# Создаём экземпляр класса, запускаем скрипт и выводим всё это дело в консоль.
solution = Solution()

print()
print('Ввод: 25525511135')
print('Вывод:', solution.restoreIpAddresses("25525511135"))
print('='*65, '\n')

print('Ввод: 0000')
print('Вывод:', solution.restoreIpAddresses("0000"))
print('='*65, '\n')

print('Ввод: 101023')
print('Вывод:', solution.restoreIpAddresses("101023"))
print('='*65, '\n')

# Это решение проверяет все возможные варианты расстановки точек и отфильтровывает
# невалидные IP адреса.

# Если говорить максимально просто:
# то этот скрипт проверяет, какие валидные IP-адреса можно получить из цифр введённой строки,
# расставляя между ними точки.
