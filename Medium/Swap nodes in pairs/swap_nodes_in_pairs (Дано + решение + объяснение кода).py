# Swap nodes in pairs.

# Дан связный список, поменяй местами каждые два соседних узла и верни его голову.
# Ты должен решить задачу без изменения значений в узлах списка (т.е. можно изменять только сами узлы).

# Пример 1:
# Вход: head = [1, 2, 3, 4]
# Выход: [2, 1, 4, 3]
# Пояснение см. в картинке Explanation.jpg в папке с проектом.

# Пример 2:
# Вход: head = []
# Выход: []

# Пример 3:
# Вход: head = [1]
# Выход: [1]

# Пример 4:
# Вход: head = [1, 2, 3]
# Выход: [2, 1, 3]

# Ограничения:
# Количество узлов в списке находится в диапазоне [0, 100]
# 0 <= значение узла <= 100.

# Импортируем тип Optional из модуля typing.
# Optional[ListNode] означает, что переменная может содержать либо объект ListNode, либо None.
from typing import Optional

# Заводим класс узла связного списка.
class ListNode:
    # __init__ - конструктор, который вызывается при создании нового узла.
    # val=0 - параметр со значением по умолчанию 0 (значение узла).
    # next=None - параметр со значением по умолчанию None (ссылка на следующий узел).
    def __init__(self, val=0, next=None):

        # self.val = val - сохраняет значение узла.
        # self.next = next - сохраняет ссылку на следующий узел.
        self.val = val
        self.next = next

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Определяем метод swapPairs, который принимает в себя ряд параметров.
    # self - ссылка на экземпляр класса.
    # head: Optional[ListNode] - голова связного списка (может быть None).
    # -> Optional[ListNode] - возвращает либо узел, либо None.
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:

    # Создаём фиктивные dummy-узлы.
    # Зачем нужен dummy?
    # Фиктивный узел упрощает обработку краевых случаев, особенно когда мы
    # меняем первые два узла списка. Без него пришлось бы отдельно обрабатывать
    # ситуацию с головой списка.
        dummy = ListNode(0) # Создаёт новый узел со значением 0 и next=None
        dummy.next = head # Устанавливает связь: следующий за dummy узел - это head

    # Заводим указатель.
    # Создаём указатель current, который изначально указывает на фиктивный узел.
    # Этот указатель будет использоваться для прохода по списку.
        current = dummy

    # Основной цикл.
    # Цикл выполняется, пока существуют два следующих узла для обмена:
    # current.next - проверяет, есть ли первый узел в паре
    # current.next.next - проверяет, есть ли второй узел в паре
    # Если хотя бы однго нет (конец списка или нечётное количество узлов), цикл завершается.
        while current.next and current.next.next:

    # Идентификация узлов для обмена.
    # Сохраняем ссылки на узлы, которые будем менять местами:
    # first - первый узел в текущей паре
    # second - второй узел в текущей паре
            first = current.next
            second = current.next.next

    # Обмен узлов (3 ключевых шага).
    # Шаг 1: первый узел теперь указывает на узел, который был после второго:
    # до 1 -> 2 -> 3
    # после 1 -> 3
            first.next = second.next

    # Шаг 2: второй узел теперь указывает на первый:
    # до 2 -> 3
    # после: 2 -> 1
            second.next = first

    # Шаг 3: предыдущий узел теперь указывает на второй узел (новый первый в паре):
    # до: current -> 1
    # после: current -> 2
            current.next = second

    # Визуализация обмена:
    # до: current -> 1 -> 2 -> 3
    # после: current -> 2 -> 1 -> 3

    # Перемещение указателя.
    # Перемещаем указатель current на два узла вперёд, чтобы подготовиться
    # к обработке следующей пары:
    # current.next - это новый первый узел в обработанной паре (бывший second).
    # current.next.next - это следующий узел после обработанной пары.
    # Теперь current указывает на узел перед следующей парой для обмена.
            current = current.next.next

    # Возврат результата. Возвращает новую голову списка.
    # dummy.next - это первый реальный узел после фиктивного.
    # Если список пустой, вернётся None.
    # Если список состоит из 1 узла, вернётся этот же узел без изменений.
        return dummy.next