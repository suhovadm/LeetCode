# Даны два целых числа: dividend (делимое) и divisor (делитель).
# Нужно выполнить деление этих двух чисел без использования операторов умножения, деления и взятия остатка.

# Целочисленное деление должно отбрасывать дробную часть, то есть производить усечение к нулю.
# Например:

# 8.345 усечётся до 8.
# -2.7335 усечётся до -2.

# Необходимо вернуть частное после dividend на divisor.

# Примечание:
# предположим, что мы работаем в среде, где целые числа хранятся в диапазоне 32-битных
# знаковых чисел [-2 в 31 степени, 2 в 31 степени -1].
# Если результат деления превышает 2 в 31 степени -1, вернуть 2 в 31 степени -1.
# Если результат меньше -2 в 31, вернуть -2 в 31 степени.

# Пример 1:
# Вход: dividend = 10, divisor = 3
# Выход: 3
# Объяснение: 10 / 3 = 3.3333…, усечение к 3

# Пример 2:
# Вход: dividend = 7, divisor = -3
# Выход: -2
# Объяснение: 7 / -3 = -2.3333…, усечение к -2

# *** Мы не можем использовать *, /, или %, поэтому мы будем использовать вычитание
# и побитовые сдвиги для ускорения деления. ***

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод divide, который принимает в себя 2 параметра:
    # dividend - делимое, целое (int) и
    # divisor - делитель, целое (int).
    # Цель -> вернуть результат деления divident // divisor,
    # соблюдая границы 32-х битного целого числа, которые будут описаны ниже.
    def divide(self, dividend: int, divisor: int) -> int:

        # Ограничения для 32-х битного целого числа.
        # Эти значения нужны, чтобы не выйти за пределы 32-х битного целого числа
        # при возвращении результата. Т.е. любой результат должен попадать в этот диапазон.
        INT_MAX = 2**31 - 1 # 2147483647
        INT_MIN = -2**31 # -2147483648

        # Обработка простых случаев.

        # Если делимое равно 0, результат деления всегда равен 0.
        if dividend == 0:
            return 0

        # Если делитель равен 1, результат - это само делимое,
        # но результат ограничен диапазоном INT_MIN и INT_MAX.
        # return не даёт уйти ниже INT_MIN и выше INT_MAX.
        if divisor == 1:
            return min(max(dividend, INT_MIN), INT_MAX)

        # Если делитель равен -1, результат - это отрицательное делимое.
        if divisor == -1:
            return min(max(-dividend, INT_MIN), INT_MAX)

        # Определяем знак результата.
        # (dividend < 0) -> True, если делимое отрицательное.
        # (divisor < 0) -> True, если делитель отрицательный.
        # != означает:
        # True, если знаки разные, False, если знаки одинаковые.
        # negative == True -> результат отрицательный.
        # negative == False -> результат положительный.
        negative = (dividend < 0) != (divisor < 0)

        # Приведение к положительным числам.
        # Берём абсолютные значения, что упрощает дальнейшую логику.
        # Все побитовые операции работают только с положительными числами.
        # Знак результата уже сохранён в переменную negative.
        dividend_abs = abs(dividend)
        divisor_abs = abs(divisor)

        # Заводим будущий результат деления. Он будет собираться по битам.
        quotient = 0

        # Заводим основной цикл деления.
        # Цикл перебирает значения i - 31, 30, 29, ... 1, 0
        # Почему 32? Потому что мы работаем с 32-х битными числами.
        for i in reversed(range(32)):

            # Проверка возможности вычитания.
            # Проверяется, помещается ли это число в текущий dividend_abs.
            # Если да - значит, текущий бит можно добавить в результат.
            if (divisor_abs << i) <= dividend_abs:

                # Вычитание и накопление частного.
                # Из делимого вычитается максимально возможный кусок.
                # В результат добавляется соответствующая степень двойки.
                # Это аналог деления, но в двоичной системе.
                dividend_abs -= divisor_abs << i
                quotient += 1 << i

        # Применение знака.
        # Если ранее было определено, что результат должен быть отрицательным - меняем знак.
        if negative:
            quotient = -quotient

        # Финальное ограничение результата. То есть, не меньше INT_MIN, не больше INT_MAX.
        # Это обязательное требование задачи.
        return min(max(quotient, INT_MIN), INT_MAX)

# Создаём экземпляр класса Solution.
solution = Solution()

# Пример 1.
print('Пример 1:')
print('Вход: dividend = 10, divisor = 3')
result1 = solution.divide(10, 3)
print(f'Выход: {result1}')
print('Объяснение: 10 / 3 = 3.3333..., усекаем до 3.')
print()

# Пример 2.
print('Пример 2:')
print('Вход: dividend = 7, divisor = -3')
result2 = solution.divide(7, -3)
print(f'Выход: {result2}')
print('Объяснение: 7 / -3 = -2.3333..., усекаем до -2.')
