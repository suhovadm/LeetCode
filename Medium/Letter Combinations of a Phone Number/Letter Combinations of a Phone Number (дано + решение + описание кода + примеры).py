# Letter Combinations of a Phone Number.

# Учитывая строку, содержащую цифры от 2 до 9 включительно, верните все возможные
# комбинации букв, которые может представлять это число. Ответ можно вернуть в любом порядке.

# Соответствие цифр буквам (как на телефонных кнопках) приведено ниже. Обратите внимание,
# что цифра 1 не соответствует никаким буквам.

# Пример 1:
# Входные данные: digits = "23"
# Результат: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

# Пример 2:
# Входные данные: digits = "2"
# Результат: ["a","b","c"]

# Импортируем тип List из модуля typing.
# Это нужно для аннотации типов - чтобы указать, что функция возвращает список строк.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Определяем метод letterCombinations, который принимает в себя ряд параметров.
    # self - ссылка на экземпляр класса.
    # digits: str - строка с цифрами.
    # -> List[str] - возврат списка строк.
    def letterCombinations(self, digits: str) -> List[str]:

        # Деляем проверку на пустой ввод.
        # Если строка digits пустая (например, ""), сразу возвращаем пустой список.
        # Это защита от некорректного ввода.
        if not digits:
            return []

        # Хардкодим словарь соответствия цифр и букв.
        # Ключ - это цифра в виде строки (потому что digits - это строка).
        # Значение - это строка со всеми буквами, соответствующими этой цифре на телефонной клавиатуре.
        phone_map = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }

        # Заводим пустой список для вывода результата.
        result = []

        # Заводим внутреннюю функцию backtrack.
        # Она определяет рекурсивную функцию для построения комбинаций:
        # - combination - текущая собранная комбинация букв,
        # - next_digits - оставшиеся цифры для обработки.
        def backtrack(combination: str, next_digits: str):

        # Базовый случай рекурсии.
        # Если не осталось цифр для обработки (next_digits пустая):
        # - добавляем текущую комбинацию в результ,
        # - завершаем текущий рекурсивный вызов (return).
            if not next_digits:
                result.append(combination)
                return

        # Получаем текущие цифры и её буквы.
        # Берём первую цифру из оставшихся.
        # Например, если next_digits = "23", то current_digit = "2".
            current_digit = next_digits[0]

        # Получаем строку с буквами для текущей цифры из словаря. Для "2" это будет "abc".
            letters = phone_map[current_digit]

        # Рекурсивный перебор.
        # Для каждой буквы из полученной строки (например, 'a', 'b', 'c'): ...
            for letter in letters:

        # ... рекурсивно вызываем backtrack ...
        # - к текущей комбинации добавляем текущую букву.
        # - Убираем первую цифру из next_digits (берём срез со второго элемента до конца).
                backtrack(combination + letter, next_digits[1:])

        # Запускаем рекурсию.
        # Запускаем процесс с пустой начальной комбинацией и всеми цифрами,
        # которые нужно обработать.
        backtrack("", digits)

        # Возврат результата.
        return result

# Создаём объект класса Solution, выводим примеры в консоль.
solution = Solution()

# Пример 1, 9 комбинаций на двух кнопках "23".
digits1 = "23"
result1 = solution.letterCombinations(digits1)
print(f"Входные данные: digits = {digits1}")
print(f"Результат: {result1}\n")  # Ожидаемый результат: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

# Пример 2, 3 комбинации на одной кнопке "2".
digits2 = "2"
result2 = solution.letterCombinations(digits2)
print(f"Входные данные: digits = {digits2}")
print(f"Результат: {result2}")  # Ожидаемый результат: ["a","b","c"]

# Пример 3, 27 комбинаций на трёх кнопках "234".
digits3 = "234"
result3 = solution.letterCombinations(digits3)
print(f"Входные данные: digits = {digits3}")
print(f"Результат: {result3}")
# Ожидаемый результат: комбинации всех букв для "2", "3", "4"
# ['adg', 'adh', 'adi', 'aeg', 'aeh', 'aei', 'afg', 'afh', 'afi',
#  'bdg', 'bdh', 'bdi', 'beg', 'beh', 'bei', 'bfg', 'bfh', 'bfi',
#  'cdg', 'cdh', 'cdi', 'ceg', 'ceh', 'cei', 'cfg', 'cfh', 'cfi']