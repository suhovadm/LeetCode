# Импортируем тип List из модуля typing. Это нужно для аннотации типов, чтобы
# указать, что функция принимает и возвращает списки.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Объявляем метод fourSum внутри класса, который принимает в себя ряд параметров.
    # nums: List[int] - список целых чисел.
    # target: int - целое число.
    # -> List[List[int]] - возвращает список списков целых чисел (наши четвёрки).
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:

    # Подготовительный этап.

    # Сортируем массив по возрастанию.
    # Зачем это нужно?
    # - Для использования метода двух указателей.
    # - Легкого пропуска дубликатов.
    # - Возможности использовать оптимизации с минимальными/максимальными суммами.
        nums.sort()

    # n - сохраняет длину массива для удобства использования.
    # result - будет хранить все найденные уникальные четвёрки.
        n = len(nums)
        result = []

    # Первый цикл (выбор первого числа).
    # Здесь мы проходим от начала до n-4 включительно, т.к. нам нужно оставить минимум 3
    # числа после i для формирования четвёрки.
        for i in range(n - 3):

    # Пропуск дубликатов для первого числа: если текущее число равно предыдущему, пропускаем
    # итерацию. Это гарантирует, что каждая четвёрка начинается с уникального первого числа.
            if i > 0 and nums[i] == nums[i - 1]:
                continue

    # Ключевые оптимизации для первого цикла.

    # Оптимизация 1 (максимальная сумма): проверяем минимальную возможную сумму с текущим
    # nums[i] (берём три следующих самых маленьких числа). Если даже эта минимальная сумма больше
    # target, то с текущим nums[i] и любыми бОльшимими числами сумма будет только расти - можно
    # завершить весь цикл брейком.
            if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target:
                break

    # Оптимизация 2 (минимальная сумма): проверяем максимально возможную сумму с текущим nums[i].
    # Берём три самых больших числа в конце массива. Если это максимальная сумма меньше target, то
    # с текущим nums[i] мы никогда не достигнем цели - можно пропустить эту итерацию и перейти
    # к следующему i, т.е. выполнить continue...
            if nums[i] + nums[n-1] + nums[n-2] + nums[n-3] < target:
                continue

    # Второй цикл (выбор второго числа).
    # Второе число выбирается после первого, оставляя место для двух указателей.
            for j in range(i + 1, n - 2):

    # Пропуск дубликатов для второго числа: если текущее второе число равно предыдущему
    # (при том же первом числе), пропускаем итерацию - continue.
                if j > i + 1 and nums[j] == nums[j - 1]:
                    continue

    # Оптимизация для второго цикла.
    # Оптимизация 3 (максимальная сумма): проверяем минимально возможную сумму с
    # фиксированными nums[i] и nums[j] (берём два следующих самых маленьких числа).
    # Если она больше target - можно завершить внутренний цикл брейком, так как с
    # ростом j сумма будет только увеличиваться.
                if nums[i] + nums[j] + nums[j+1] + nums[j+2] > target:
                    break

    # Оптимизация 4 (минимальная сумма): проверяем максимально возможную сумму с
    # фиксированными nums[i] и nums[j] (берём два самых больших числа в конце).
    # Если она меньше target - с текущим j мы не достигнем цели, но с бОльшими j
    # сумма может вырасти - пропускаем итерацию с помощью continue...
                if nums[i] + nums[j] + nums[n-1] + nums[n-2] < target:
                    continue

    # Два указателя (поиск третьего и четвёртого чисел).
    # Устанавливаем указатели:
    # left начинает сразу после j,
    # right начинает с конца массива.
                left = j + 1
                right = n - 1

    # Пока указатели не встретились, ищем комбинации.
    # Вычисляем текущую сумму.
                while left < right:
                    current_sum = nums[i] + nums[j] + nums[left] + nums[right]

    # Если нашли искомую сумму, добавляем четверку в результат.
                    if current_sum == target:
                        result.append([nums[i], nums[j], nums[left], nums[right]])

    # Пропуск дубликатов для третьего и четвёртого чисел.
    # Пропускаем все дубликаты для третьего числа (сдвигаем left до последнего вхождения).
                        while left < right and nums[left] == nums[left + 1]:
                            left += 1

    # Пропускаем все дубликаты для четвёртого числа (сдвигаем right до первого вхождения).
                        while left < right and nums[right] == nums[right - 1]:
                            right -= 1

    # После обработки дубликатов сдвигаем оба указателя для поиска новых комбинаций.
                        left += 1
                        right -= 1

    # Движение указателей при неравенстве суммы.
    # Если сумма меньше цели, нужно увеличить сумму - двигаем левый указатель
    # вправо (к бОльшим числам).
                    elif current_sum < target:
                        left += 1
    # Если сумма больше цели, нужно уменьшить сумму - двигаем правый указатель влево
    # (к меньшим числам).
                    else:
                        right -= 1

    # Возвращаем все найденные уникальные четвёрки.
        return result