# Substring_with_Concatenation_of_All_Words  

# Файлы:  
# Substring_with_Concatenation_of_All_Words (решение + объяснение кода)  
# Substring_with_Concatenation_of_All_Words (дано + решение без объяснения кода + описание, как работает алгоритм)  
# Substring_with_Concatenation_of_All_Words_Example (примеры с выводом в консоль через отдельную функцию)  

# Подстрока, содержащая конкатенацию всех слов.  

# Вам дана строка s и массив строк words. Все строки в words имеют одинаковую длину.  
# Конкатенированная строка - это строка, которая в точности содержит все строки  
# из некоторой перестановки words, соединённые вместе.  

# Например, если words = ["ab","cd","ef"], то "abcdef", "abefcd", "cdabef", "cdefab", "efabcd" и "efcdab"  
# являются конкатенированными строками. "acdbef" не является конкатенированной строкой, потому что это не  
# конкатенация какой-либо перестановки слов из words. Верните массив начальных индексов всех конкатенированных  
# подстрок в s. Ответ можно возвращать в любом порядке.  

# Пример 1:  
# Входные данные: s = "barfoothefoobarman", words = ["foo","bar"]  
# Реузльтат: [0, 9]  

# Пояснение:  
# Подстрока, начинающаяся с индекса 0 - это "barfoo". Она является конкатенацией ["bar", "foo"],  
# что является перестановкой words.  
# Подстрока, начинающаяся с индекса 9 - это "foobar". Она является конкатенацией ["foo", "bar"],  
# что является перестановкой words.  

# Пример 2:  
# Входные данные: s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]  
# Результат: []  

# Пояснение:  
# Конкатенированных подстрок не существует.  

# Пример 3:  
# Входные данные: s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]  
# Результат: [6, 9, 12]  

# Пояснение:  
# Подстрока, начинающаяся с индекса 6 - это "foobarthe". Она является конкатенацией  
# ["foo","bar","the"].  
# Подстрока, начинающаяся с индекса 9 - это "barthefoo". Она является конкатенацией  
# ["bar","the","foo"].  
# Подстрока, начинающаяся с индекса 12 - это "thefoobar". Она является конкатенацией  
# ["the","foo","bar"].  

# Ограничения:  
# 1 <= s.length <= 10^4  
# 1 <= words.length <= 5000  
# 1 <= words[i].length <= 30  
# s и words[i] состоят из строчных букв английского алфавита.  

-----------------------------------------------------------------------------------------------

# Как работает алгоритм?  

# 1. Подготовка: вычисляем длину каждого слова, общую длину всех слов  
# и проверяем базовые случаи.  

# 2. Используем скользящее окно, которое двигается с шагом в длину слова.  
# Это позволяет эффективно проверять все возможные комбинации.  

# 3. Особенности реализации:  
# - внешний цикл for i in range(word_length) позволяет обработать все возможные начальные  
# позиции с учётом сдвига.  
# - Используем два указателя left и right для скользящего окна.  
# - current_freq отслеживает частоту слов в текущем окне.  
# - word_freq содержит ожидаемую частоту каждого слова.  

# 4. Логика обработки:  
# - если находим слово из списка, добавляем его в текущее окно.  
# - Если слово встречается слишком часто, сдвигаем левую границу.  
# - Когда находим все слова, добавляем индекс в результат.  
# - Если встречаем слово не из списка, сбрасываем окно.  

# Сложность:  
# Время: O(n * m), где n - длина строки, m - длина слова  
# Память: O(k), где k - количество уникальных слов  

# Это решение эффективно работает даже для больших входных данных благодаря  
# использованию скользящего окна и избеганию лишних проверок.  
