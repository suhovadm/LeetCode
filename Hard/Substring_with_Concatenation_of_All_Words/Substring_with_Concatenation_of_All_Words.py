# Substring_with_Concatenation_of_All_Words

# Импортируем List для типизации (указываем, что функция возвращает список целых чисел).
from typing import List
# Counter - специальный словарь для подсчёта количества объектов.
# defaultdict - словарь, который возвращает значение по умолчанию (0 для инта) при обращении
# к несуществующему ключу.
from collections import Counter, defaultdict

# Определяем класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод findSubstring, который принимает в себя ряд параметров.
    # Метод принимает строку s и список words.
    # Возвращает список чисел, т.е. индексы начала подстрок.
    def findSubstring(self, s: str, words: List[str]) -> List[int]:

        # Проверка граничных случаев.
        # Если строка пустая или список слов пустой - возвращаем пустой список.
        # not s проверяет, что строка не пустая (в Python пустая строка = False).
        # Это защита от некорректных входных данных.
        if not s or not words:
            return []

        # Заводим переменные.
        word_length = len(words[0]) # Длина одного слова.
        word_count = len(words) # Кол-во слов в массиве.
        total_length = word_length * word_count # Общая длина, которую будет иметь конк. строка.
        s_length = len(s) # Длина исходной строки.

        # Если строка короче, чем нужная нам подстрока - ответа быть не может.
        # Например, ищем подстроку длиной 6 в строке длины 3.
        if s_length < total_length:
            return []

        # Подготовка к поиску.
        # word_freq - словарь, где ключ - слово, значение - сколько раз оно встречается в words.
        # Например, для words = ["foo", "bar", "foo"] получим {"foo": 2, "bar": 1}
        word_freq = Counter(words)
        result = [] # result - список для хранения найденных индексов.

        # Основной цикл по возможным сдвигам.
        # Здесь мы проверяем все возможные начальные позиции с учётом длины слова.
        # Например, если длина слова = 3, то возможные начальные позиции 0, 1, 2
        # Это позволяет не пропустить ни одной подстроки.
        for i in range(word_length):

            # Заводим переменные для текущего окна.
            # left и right - границы скользящего окна (левый и правый указатели).
            left = i
            right = i

            # current_count - сколько валидных слов мы нашли в текущем окне.
            current_count = 0
            # defaultdict(int) - автоматически создаёт ключ со значением 0, если ключ отсутствует.
            current_freq = defaultdict(int)

            # Заводим основной цикл обработки.
            # Пока можем взять следующее слово (не выходим за границы строки).
            # right + word_length - позиция конца следующего слова.
            while right + word_length <= s_length:

                # Извлечение текущего слова.
                # Извлекаем слово текущей длины из строки.
                # Сдвигаем правую границу на длину слова.
                word = s[right:right + word_length]
                right += word_length

                # Обработка найденного слова.
                # Проверяем, есть ли это слово в нашем целевом списке.
                if word in word_freq:

                    # Если слово есть в списке:
                    # - увеличиваем счётчик этого слова в текущем окне,
                    # - увеличиваем общее количество найденных слов.
                    current_freq[word] += 1
                    current_count += 1

                    # Балансировка окна (слишком много одинаковых слов).
                    # Если текущее слово встречается чаще, чем нужно (например нужно 2 "foo", а мы нашли 3),
                    # - удаляем самое левое слово из окна,
                    # - уменьшаем его счётчик и общее количество,
                    # - сдвигаем левую границу,
                    # - продолжаем пока не восстановим баланс.
                    while current_freq[word] > word_freq[word]:
                        left_word = s[left:left + word_length]
                        current_freq[left_word] -= 1
                        current_count -= 1
                        left += word_length

                    # Найдена полная комбинация.
                    # Если кол-во найденных слов равно нужному количеству - мы нашли результат.
                    # Добавляем левую границу (начало подстроки) в результ.
                    if current_count == word_count:
                        result.append(left)

                    # Сдвиг окна после нахождения результата.
                    # Удаляем самое левое окно.
                    # Это позволяет продолжить поиск других подстрок.
                    # Сдвигаем окно на одно слово вправо.
                        left_word = s[left:left + word_length]
                        current_freq[left_word] -= 1
                        current_count -= 1
                        left += word_length

                # Если слово не из списка:
                # - встретили слово, которого нет в целевом списке,
                # - очищаем текущее окно (все накопленные слова теперь недействительны),
                # - сбрасываем счётчики,
                # - передвигаем левую границу на текущую правую.
                else:
                    current_freq.clear()
                    current_count = 0
                    left = right

        # Возвращаем все найденные индексы.
        return result