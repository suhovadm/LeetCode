# Wildcard Matching.

# Дана входная строка (s) и шаблон (p), реализуйте сопоставление с подстановочными знаками
# с поддержкой '?' и '*', где:

# '?' соответствует любому одному символу.
# '*' соответствует любой последовательности символов (включая пустую последовательность).
# Сопоставление должно охватывать всю входную строку (не частично).

# Пример 1:
# Ввод: s = "aa", p = "a"
# Вывод: false
# Пояснение: "a" не соответствует всей строке "aa".

# Пример 2:
# Ввод: s = "aa", p = ""
# Вывод: true
# Пояснение: " соответствует любой последовательности.

# Пример 3:
# Ввод: s = "cb", p = "?a"
# Вывод: false
# Пояснение: '?' соответствует 'c', но вторая буква в шаблоне - 'a', которая не соответствует 'b',
# в строке.

# Ограничения:
# 0 <= s.length, p.length <= 2000
# s содержит только строчные английские буквы.
# p содержит только строчные английские буквы, '?' или '*'.

# ---------------------------------------------------------------------------------- #

# Реализация "жадного алгоритма".

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод isMatch, который принимает в себя ряд параметров.
    # s - исходная строка.
    # p - шаблон.
    # -> bool, возвращает True, если строки совпадают, False, если нет.
    def isMatch(self, s: str, p: str) -> bool:

        # Длины строк.
        # n - длина строки s.
        # m - длина шаблона p.

        # Пример:
        # s = "aaabxczzc" -> n = 9 // Это длина строки.
        # p = "*a*b?c*" -> m = 7 // Это длина шаблона.

        n, m = len(s), len(p)

        # Указатели строки и шаблона.
        # i - указатель по строке s.
        # j - указатель по шаблону p.
        # Оба начинаются с начала.
        # Это позиции текущих символов: s[i], p[j].
        i = j = 0

        # Переменные для работы со *
        # star_idx - позиция последней * в шаблоне.
        # -1 значит, что * ещё не было.
        # Любое другое значение, значит * в шаблоне.
        star_idx = -1

        # Означает, с какого индекса строки s текущая * начала захватывать символы.
        match = 0

        # Главный цикл.
        # Цикл выполняется пока в строке s есть символы.
        # Если i == n -> строка полностью обработана -> выходим из цикла.
        while i < n:

            # Случай 1: символы совпадают.
            # Проверяем:
            # j < m - чтобы не выйти за пределы шаблона.
            # p[j] == s[i] - точное совпадение.
            # p[j] == '?' - ? Универсальный символ, подходит под любое значение.
            # Если любой из пунктов 2-3 истинен, условие проходит.
            if j < m and (p[j] == '?' or p[j] == s[i]):

                # Если условие истинно:
                # мы "съели" один символ строки,
                # мы "съели" один символ шаблона.
                i += 1
                j += 1

            # Случай 2: найдена *
            # Текущий символ шаблона - *.
            # Что делает * в этом алгоритме?
            # Она говорит: "я могу соответствовать любому количеству символов строки,
            # но начёнм с нуля."
            elif j < m and p[j] == '*':

                # Запоминаем, где именно находится *.
                star_idx = j

                # Запоминаем с какого символа строки * начала совпадение.
                # Пока * считается как пустая строка.
                match = i

                # Переходим к следующему символу шаблона.
                # Строку пока не трогаем!
                j += 1

            # Случай 3: несовпадение, но ранее была *
            # Текущие символы не совпали, но:
            # ранее мы встречали *
            # значит, можно попробовать, чтобы * "съела" ещё один символ.
            elif star_idx != -1:

                # Откат.
                # Возвращаемся к шаблону сразу после *.
                j = star_idx + 1

                # Говорим: "теперь * захватывает на 1 символ строки больше".
                match += 1

                # Передвигаем указатель строки вперёд.
                i = match

            # Случай 4: тупик.
            # Символы не совпали.
            # * раньше не было. Совпадение не возможно!
            # Вариантов больше нет!
            else:
                return False

        # Эта часть идёт ПОСЛЕ цикла!
        # Очищаем хвост шаблона.
        # После выхода из цикла строка s уже закончилась.
        # Зачем это нужно?
        # s = "abc"
        # p = "abc***"
        # * может означать пустую строку.
        while j < m and p[j] == '*':
            j += 1

        # Финальная проверка.
        # Если мы дошли до конца шаблона - полное совпадение.
        # Если нет - значит в шаблоне остались символы, которые нельзя сопоставить.
        return j == m

# Жадный алгоритм: самый эффективный и самый быстрый - O(n+m) времени и O(1) памяти.
# То есть, он использует минимум памяти.
# Он работает, отслеживая последнюю встреченную '*' и пробуя разные способы её использования.