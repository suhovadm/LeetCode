from Minimum_Operations_to_Equalize_Binary_String import *

# Примеры использования:
if __name__ == "__main__":
    solution = Solution()

    print('\nОсновные тесты:')

    # Пример 1.
    s1, k1 = "110", 1
    result1 = solution.minOperations(s1, k1)
    print(f"Пример 1: s = '{s1}, k = {k1} -> {result1}'")
    print(f'Количество операций: {result1}')

    # В строке один ноль на позиции 2.
    # За одну операцию можно инвертировать этот ноль в еденицу.
    # Результат: 1 операция.

    # Пример 2.
    s2, k2 = "0101", 3
    result2 = solution.minOperations(s2, k2)
    print(f"Пример 2: s = '{s2}, k = {k2} -> {result2}'")
    print(f'Количество операций: {result2}')

    # В строке два нуля на позициях 1 и 3.
    # Нужно инвертировать ровно 3 символа за операцию.
    # Оптимально:
    # Операция 1: инвертируем [0,1,3] -> "0101" -> "1000"
    # Операция 2: инвертируем [1,2,3] -> "1000" -> "1111"

    # Пример 3.
    s3, k3 = "101", 2
    result3 = solution.minOperations(s3, k3)
    print(f"Пример 3: s = '{s3}, k = {k3} -> {result3}'")
    print(f'Количество операций: {result3}')

    # В строке один ноль на позиции 1.
    # За операцию нужно инвертировать ровно 2 символа, но можно выбрать только один ноль.
    # Если инвертировать ноль, придётся инвертировать ещё одну еденицу, что создаст новый ноль.
    # Результат: -1 (невозможно).

    print("\nДополнительные тесты:")

    # Тест 4: строка уже из едениц.
    s4, k4 = "111", 2
    result4 = solution.minOperations(s4, k4)
    print(f"Тест 4 (уже все еденицы): s = '{s4}, k = {k4} -> {result4}'")
    print(f'Количество операций: {result4}')

    # В строке нет нулей.
    # Цель уже достигнута.
    # Результат: 0 операций.

    # Тест 5: строка из всех нулей.
    s5, k5 = "000", 2
    result5 = solution.minOperations(s5, k5)
    print(f"Тест 5 (все нули): s = '{s5}, k = {k5} -> {result5}'")
    print(f'Количество операций: {result5}')

    # Три нуля, за операцию инвертируем 2 символа.
    # Нельзя добиться всех едениц (не получается нужная чётность инверсий).
    # Результат: -1.

    # Тест 6: k больше половины строки.
    s6, k6 = "010", 2
    result6 = solution.minOperations(s6, k6)
    print(f"Тест 6: s = '{s6}', k = {k6} -> {result6}")
    print(f"Количество операций: {result6}")

    # В строке два нуля на позициях 0 и 2.
    # За одну операцию можно инвертировать оба нуля (индексы [0, 2]).
    # После инверсии "010" превращается в "111".
    # Результат: 1 операция.

    # Тест 7: длинная строка.
    s7, k7 = "0101010101", 5
    result7 = solution.minOperations(s7, k7)
    print(f"Тест 7: s = '{s7}', k = {k7} -> {result7}")
    print(f'Количество операций: {result7}')

    # Пять нулей на чётных позициях (0, 2, 4, 6, 8) и пять едениц на нечётных.
    # За одну операцию можно инвертировать все нули (индексы [0, 2, 4, 6, 8]).
    # После инверсии "0101010101" превращается в "1111111111".
    # Результат: 1 операция.

# Конечный результат работы алгоритма - это минимальное количество операций,
# необходимых для превращения всех символов строки в '1'.
# Если это возможно, возвращается число операций.
# Если невозможно, возвращается -1.
# Если строка уже состоит из едениц, возвращается 0.