# Minimum Operations to Equalize Binary String

# Вам дана бинарная строка s и целое число k.

# За одну операцию вы должны выбрать ровно k различных индексов и инвертировать каждый
# символ: '0' заменить на '1', а '1' заменить на '0'.

# Верните минимальное количество операций, необходимых для того, чтобы все символы в строке
# стали равны '1'. Если это невозможно, верните -1.

# Пример 1:
# Входные данные: s = "110", k = 1
# Выходные данные: 1
# Объяснение:
# В s есть один '0'.
# Так как k = 1, мы можем инвертировать его напрямую за одну операцию.

# Пример 2:
# Входные данные: s = "0101", k = 3.
# Выходные данные: 2
# Объяснение:
# Один из оптимальных наборов операций с выбором k = 3 индексов в каждой операции:

# операция 1: инвертируем индексы [0, 1, 3]. s меняется с "0101" на "1000",
# операция 2: инвертируем индексы [1, 2, 3]. s меняется с "1000" на "1111".
# Таким образом, минимальное количество операций равно 2.

# Пример 3:
# Входные данные: s = "101", k = 2
# Выходные данные: -1
# Объяснение:
# так как k = 2 и в s только один '0', невозможно инвертировать ровно k индексов, чтобы
# получить все '1'. Следовательно, ответ -1.

# Ограничения:

# 1 <= длина s <= 10⁵
# s[i] — это либо '0', либо '1'.
# 1 <= k <= длина s

# --------------------------------------------------------------------------------- #

# Решение 100% правильное. Взято с канала impoldev
# Ссылка на канал: https://www.youtube.com/watch?v=Iay9AdwZZ1E

# Общая идея:
# решение пытается найти минимальное количество операций (op), при котором можно
# превратить все нули в еденицы, перебирая возможное количество операций от 1 до n
# и проверяя, можно ли за op операций добиться цели.

# --------------------------------------------------------------------------------- #

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Определяем метод minOperations, который принимает в себя ряд параметров.
    # Метод принимает в себя строку s и целое число k, а затем возвращает целое число.
    def minOperations(self, s: str, k: int) -> int:

        # Получеам длину строки и сохраняем в переменную n.
        n = len(s)
        # Заводим счётчики: z - количество нулей, o - количество едениц.
        z, o = 0, 0

        # Проходимся циклом по каждому символу строки.
        # Если символ '0', увеличиваем счётчик нулей на 1.
        # Иначе (символ '1') увеличиваем счётчик едениц на 1.
        for c in s:
            if c == '0': z += 1
            else: o += 1

        # Если нулей нет (строка уже состоит только из едениц), возвращаем 0.
        if z == 0: return 0

        # Запускаем цикл перебора возможного количества операций.
        # Перебираем возможное количество операций от 1 до n (включительно).
        # Почему до n? Потому что больше n операций точно не нужно - если делать
        # больше, чем длина строки, мы будем бессмысленно повторять операции.
        for op in range(1, n + 1):
            # Вычисляем количество инверсий (flips) за все операции. Так как за одну операцию
            # мы инвертируем ровно k символов, то за op операций будет инвертировано op * k
            # символов (с учётом повторов - один и тот же индекс может инвертироваться несколько
            # раз в разных операциях).
            flips = op * k
            # Проверка на чётность. Разница между общим количеством инверсий и количеством
            # нулей должна быть чётной. Почему?
            # Каждый ноль должен быть инвертирован нечётное количество раз (чтобы из 0 стать 1)
            # Каждая еденица должна быть инвертирована чётное количество раз (чтобы остаться 1)
            # Среди нулей: сумма нечётных чисел даёт нечётность, равную количеству нулей (z)
            # Среди едениц: сумма чётных чисел даёт чётность
            # Поэтому flips и z должны иметь одинаковую чётность, то есть (flips - z) чётно
            if (flips - z) % 2 == 1: continue

            # Если количество операций чётное:
            # проверяем, что flips находится в допустимом диапазоне:
            # минимум: нужно инвертировать каждый ноль хотя бы 1 раз, т.е. минимум z инверсий,
            # максимум: при чётном количестве операций:
            # - нули могут быть инвертированы максимум op раз (каждый ноль во всех операциях),
            # - еденицы могут быть инвертированы максимум (op-1) раз (так как при чётном количестве
            # операций еденицы должны инвертироваться чётное число раз, максимальное чётное ≤ op -
            # это op-1 если op чётное).
            # Поэтому максимальное количество инверсий = z * op + o * (op-1).
            if op % 2 == 0:
                if z <= flips <= z * (op - 1) + o * op: return op

            # Если количество операций нечётное:
            # - минимум всё тот же: z инверсий,
            # - максимум:
            # нули могут быть инвертированы максимум op раз (каждый ноль во всех операциях).
            # Еденицы могут быть инвертированы максимум (op-1) раз (при нечётном количестве
            # операций единицы должны инвертироваться чётное число раз, максимальное чётное
            # ≤ op - это op-1).
            # Поэтому максимальное количество инверсий = z * op + o * (op-1).
            else:
                if z <= flips <= z * op + o * (op - 1): return op

        # Если ни для одного количества операций не нашлось подходящего значения flips,
        # возвращаем -1 (невозможно решить задачу).
        return -1

# Ключевые моменты:
# 1. Решение перебирает количество операций, а не ищет конкретные индексы для инвертирования.
# 2. Оно использует математические свойства чётности для проверки возможности решения.
# 3. Ограничение диапазона flips гарантирует, что можно распределить инверсии между нулями и
# еденицами так, чтобы нули инвертировались нечётное количество раз, а еденицы - чётное.
# 4. Решение возвращает первое найдённое количество операций, т.к. перебор идёт от
# меньшего к большему.