# Дано: массив из k связанных списков lists, каждый связанный список отсортирован по возрастанию.

# Объедините все связанные списки в один отсортированный связанный список и верните его.

# Пример 1:
# Ввод: lists = [[1,4,5],[1,3,4],[2,6]]
# Вывод: [1,1,2,3,4,4,5,6]

# Объяснение:
# Даны списки:
# 1>4>5,
# 1>3>4,
# 2>6
# После объединения в один отсортированный список:
# 1>1>2>3>4>4>5>6

# Пример 2:
# Ввод: lists = []
# Вывод: []

# Пример 3:
# Ввод: lists = [[]]
# Вывод: []

# Ограничения:
# k == lists.length
# 0 <= k <= 10?
# 0 <= lists[i].length <= 500
# -10? <= lists[i][j] <= 10?
# lists[i] отсортирован по возрастанию
# Суммарное количество элементов во всех списках не превысит 10?.

# Наша задача - собрать все значения в массив, отсортировать и создать новый связный список.

# ----------------------------------------------------------------------------- #

# Импортируем типы из модуля typing.
# List - указывает на тип "список".
# Optional - указывает, что значение может быть указанного типа или None.
from typing import List, Optional

# Заводим класс ListNode. Это определение класса для узла связанного списка.
class ListNode:

    # Заводим конструктор с рядом параметров.
    # val=0 - значение узла, по умолчанию 0.
    # next=None - ссылка на следующий узел, по умолчанию None.
    def __init__(self, val=0, next=None):

        # self.val = val - сохраняем значение в атрибуте объекта.
        # self.next = next - сохраняем ссылку на следующий узел.
        self.val = val
        self.next = next

# В LeetCode, класс ListNode и импорты from typing import List, Optional
# уже определены в системе. Их использовать не надо. Нужно использовать
# только класс Solution и всё что в нём.
# Одним словом, в данной конкретной задаче, LeetCode использует свой внутренний
# класс ListNode.

# ----------------------------------------------------------------------------- #

# Заводим класс Solution, как того требует LeetCode.
class Solution:

    # Заводим метод для объединения списков.
    # lists: List[Optional[ListNode]] - параметр: список, где каждый элемент либо ListNode
    # (головной узел), либо None.
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

        # Заводим пустой список values для хранения всех значений их всех связных списков.
        values = []

        # Проходимся циклом по всем связным спискам в массиве lists.
        # head - переменная, которая будет указывать на начало текущего списка (или None).
        for head in lists:

            # Цикл while будет работать пока не дойдём до конца текущего связного списка.
            while head:

                # values.append(head.val) - добавляем значение текущего узла в список values.
                values.append(head.val)
                # head = head.next - переходим к следующему узлу связного списка.
                head = head.next

        # Проверяем, собрали ли мы какие-либо значения.
        # Если список values пуст...
        if not values:
            return None # ... возвращаем None (пустой связанный список).

        # Сортируем все собранные значения по возрастанию.
        values.sort()

        # Создаём фиктивный узел. Так называемый dummy.
        # ListNode(0) - узел со значением 0.
        # Это узел-заглушка от которого мы будем строить новый список.
        dummy = ListNode(0)

        # Создаём указатель curr, который изначально указывает на фиктивный узел.
        # curr всегда указывает на последний узел нового списка.
        curr = dummy

        # Проходимся циклом по всем отсортированным значениям.
        for v in values:

            # curr.next = ListNode(v) - создаём новый узел со значением v и привязываем его
            # к последнему узлу.
            curr.next = ListNode(v)

            # curr = curr.next - перемещаем указатель curr на только что созданный узел.
            # Теперь он (узел) последний.
            curr = curr.next

        # Возвращаем реальное начало нового списка.
        # dummy.next - следующий узел после фиктивного, то есть первый реальный
        # узел нового отсортированного списка.
        return dummy.next