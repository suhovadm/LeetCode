# Дан головной узел связного списка.
# Необходимо развернуть узлы списка группами по k штук и вернуть изменённый список.

# k — целое положительное число, не превышающее длину связного списка.
# Если количество узлов не кратно k, то оставшиеся в конце узлы должны остаться в исходном порядке.

# Запрещается изменять значения в узлах списка, можно менять только сами узлы.

# Пример 1:
# Ввод: head = [1,2,3,4,5], k = 2
# Вывод: [2,1,4,3,5]

# Пример 2:
# Ввод: head = [1,2,3,4,5], k = 3
# Вывод: [3,2,1,4,5]

# Импортируем Optional для аннотации типов (указывает, что значение может быть либо ListNode, либо None).
from typing import Optional

# Заводим класс для узла связанного списка.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val  # Значение узла.
        self.next = next # Ссылка на следующий узел (по умолчанию None).

# Класс Solution, как того требует LeetCode.
# Основная часть, которая разворачивает связанный список группами по k узлов.
# head: первый узел списка (может быть None, если список пустой).
# k: размер группы для разворота.
# Возвращает: новый головной узел изменённого списка.
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:

        # Вложенная функция для разворота части списка.
        # Разворачивает часть связанного списка от start (включительно) до end (исключительно).
        # start: первый узел разворачиваемого сегмента.
        # end: узел, следующий ПОСЛЕ последнего узла разворачиваемого сегмента.
        # Возвращает: новый первый узел развернутого сегмента.
        def reverse(start, end):
            prev = None # Предыдущий узел (изначально None).
            curr = start    # Текущий узел, начинаем с start.

            # Итерируемся, пока не дойдем до конца сегмента.
            while curr != end:
                next_node = curr.next # Сохраняем ссылку на следующий узел.
                curr.next = prev    # Перенаправляем текущий узел на предыдущий (разворот).
                prev = curr         # Сдвигаем prev на текущий узел.
                curr = next_node    # Переходим к следующему узлу.

            # prev теперь указывает на последний узел сегмента (ставший первым).
            return prev

        # Шаг 1: проверяем, есть ли в текущем сегменте как минимум k узлов.
        count = 0       # Счётчик узлов.
        node = head     # Указатель для обхода списка.

        # Проходим k узлов или до конца списка.
        while count < k and node:
            node = node.next    # Переходим к следующему узлу.
            count += 1          # Увеличиваем счётчик.

        # Шаг 2: если узлов меньше k, не разворачиваем, возвращаем как есть.
        if count < k:
            return head # Недостаточно узлов для разворота группы.

        # Шаг 3: разворачиваем текущую группу из k узлов.
        # На этом моменте:
        # - head: начало текущей группы.
        # - node: узел, следующий ПОСЛЕ конца текущей группы (k+1-й узел или None).
        new_head = reverse(head, node) # Разворачиваем группу от head до node

        # Шаг 4: рекурсивно обрабатываем оставшуюся часть списка.
        # После разворота:
        # - new head: новый первый узел развернутой группы (бывший последний).
        # - head: теперь последний узел развернутой группы (бывший первый).
        # head.next должен указывать на результат разворота следующей группы.
        head.next = self.reverseKGroup(node, k) # node - начало слеудющей группы.

        # Шаг 5: возвращаем новый головной узел для текущего сегмента.
        return new_head

# Детальный размотр процесса:
# Для примера: [1 → 2 → 3 → 4 → 5], k=2
# Первая итерация:
# head = 1, k = 2
# Считаем 2 узла: node становится 3, count = 2
# Разворачиваем [1 → 2] в [2 → 1]:
# reverse(1, 3) возвращает 2 (новый головной узел)
# new_head = 2
# Рекурсивный вызов: reverseKGroup(3, 2) (обработает [3 → 4 → 5])
# head.next (1.next) = результат рекурсии
# Возвращаем new_head (2)
# Рекурсия для [3 → 4 → 5]:
# Считаем 2 узла: node становится 5, count = 2
# Разворачиваем [3 → 4] в [4 → 3]
# new_head = 4
# Рекурсивный вызов: reverseKGroup(5, 2)
# Рекурсия для [5]:
# Считаем узлы: доходим до конца после одного узла, count = 1
# count < k (1 < 2), поэтому возвращаем 5 без изменений
# Собираем результат:
# 1.next = 4 (из рекурсии)
# 4 → 3 → 5 (после разворота и присоединения)
# 2 → 1 → 4 → 3 → 5 (итоговый список)
