# Импортируем Optional для аннотации типов (указывает, что значение может быть либо ListNode, либо None).
from typing import Optional

# Заводим класс для узла связанного списка.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val  # Значение узла.
        self.next = next # Ссылка на следующий узел (по умолчанию None).

# Класс Solution, как того требует LeetCode.
# Основная часть, которая разворачивает связанный список группами по k узлов.
# head: первый узел списка (может быть None, если список пустой).
# k: размер группы для разворота.
# Возвращает: новый головной узел изменённого списка.
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:

        # Вложенная функция для разворота части списка.
        # Разворачивает часть связанного списка от start (включительно) до end (исключительно).
        # start: первый узел разворачиваемого сегмента.
        # end: узел, следующий ПОСЛЕ последнего узла разворачиваемого сегмента.
        # Возвращает: новый первый узел развернутого сегмента.
        def reverse(start, end):
            prev = None # Предыдущий узел (изначально None).
            curr = start    # Текущий узел, начинаем с start.

            # Итерируемся, пока не дойдем до конца сегмента.
            while curr != end:
                next_node = curr.next # Сохраняем ссылку на следующий узел.
                curr.next = prev    # Перенаправляем текущий узел на предыдущий (разворот).
                prev = curr         # Сдвигаем prev на текущий узел.
                curr = next_node    # Переходим к следующему узлу.

            # prev теперь указывает на последний узел сегмента (ставший первым).
            return prev

        # Шаг 1: проверяем, есть ли в текущем сегменте как минимум k узлов.
        count = 0       # Счётчик узлов.
        node = head     # Указатель для обхода списка.

        # Проходим k узлов или до конца списка.
        while count < k and node:
            node = node.next    # Переходим к следующему узлу.
            count += 1          # Увеличиваем счётчик.

        # Шаг 2: если узлов меньше k, не разворачиваем, возвращаем как есть.
        if count < k:
            return head # Недостаточно узлов для разворота группы.

        # Шаг 3: разворачиваем текущую группу из k узлов.
        # На этом моменте:
        # - head: начало текущей группы.
        # - node: узел, следующий ПОСЛЕ конца текущей группы (k+1-й узел или None).
        new_head = reverse(head, node) # Разворачиваем группу от head до node

        # Шаг 4: рекурсивно обрабатываем оставшуюся часть списка.
        # После разворота:
        # - new head: новый первый узел развернутой группы (бывший последний).
        # - head: теперь последний узел развернутой группы (бывший первый).
        # head.next должен указывать на результат разворота следующей группы.
        head.next = self.reverseKGroup(node, k) # node - начало слеудющей группы.

        # Шаг 5: возвращаем новый головной узел для текущего сегмента.
        return new_head

def create_linked_list(values):
    # Создаём односвязный список из переданного списка значений.
    # Параметры:
    # values: список значений, которые будут преобразованы в узлы списка.
    # Возвращает:
    # head: головной узел созданного связного списка или None, если список пустой.

    # Проверяем, не пустой ли переданый список значений.
    if not values:
        return None # Если список пустой, возвращаем None (пустой связный список).

    # Создаём первый узел связного списка:
    # - values[0] - первое значение из переданного списка.
    # - Это значение становится значением первого узла.
    head = ListNode(values[0])

    # Создаём указатель current, который изначально указывает на головной узел.
    # Этот указатель будет двигаться по списку при добавлении новых узлов.
    current = head

    # Проходим по оставшимся значениям в списке (со второго до последнего).
    # values[1:] - это срез списка, содержащий все элементы кроме первого.
    for val in values[1:]:
        # Создаём новый узел с текущим значением.
        # val - текущее значение из итерации.
        current.next = ListNode(val)

        # Перемещаем указатель current на только что созданный узел.
        # Теперь current указывает на последний узел в списке.
        current = current.next

    # Возвращаем головной узел созданного связного списка.
    return head

def linked_list_to_str(head):
    # Преобразует связный список в читаемую строку для вывода в консоль.
    # Параметры:
    # head: головной узел связного списка.
    # Возвращает:
    # str: строка в формате "значение1 -> значение2 -> ... -> значениеN"
    #   или пустая строка, если список пустой.
    result = [] # Создаём пустой список для хранения значений узлов.

    # Создаём указатель current, который изначально указывает на головной узел.
    # Этот указатель будет использоваться для обхода всего списка.
    current = head

    # Начинаем цикл обхода связного списка.
    # Цикл продолжается, пока current не станет None.
    # None означает, что мы достигли конца списка.
    while current:

        # Преобразуем значение текущего узла в строку и добавляем в список result.
        # str(current.val) - преобразует числовое значение в строку.
        result.append(str(current.val))

        # Перемещаем указатель current на следующий узел в списке.
        # current.next - это ссылка на следующий узел.
        # Если это последний узел, current.next будет None, и цикл завершится.
        current = current.next

    # Соединяем все строковые значения из списка result в одну строку.
    # " -> ".join(result) - вставляет " -> " между каждыми двумя элементами списка.
    # Пример: для result = ["1", "2", "3"] получим: 1 -> 2 -> 3.
    return " -> ".join(result)

# Создаём экземпляр класса.
solution = Solution()

print('Пример 1:')
print('Вход: [1, 2, 3, 4, 5], k = 2')
list1 = create_linked_list([1, 2, 3, 4, 5])
print(f'Исходный список: {linked_list_to_str(list1)}')
result1 = solution.reverseKGroup(list1, 2)
print(f'Результат: {linked_list_to_str(result1)}')
print('Ожидаемый вывод: 2 -> 1 -> 4 -> 3 -> 5')

print('\n' + '='*60 + '\n')

print('Пример 2:')
print('Вход: [1, 2, 3, 4, 5], k = 3')
list2 = create_linked_list([1, 2, 3, 4, 5])
print(f'Исходный список: {linked_list_to_str(list2)}')
result2 = solution.reverseKGroup(list2, 3)
print(f'Результат: {linked_list_to_str(result2)}')
print('Ожидаемый вывод: 3 -> 2 -> 1 -> 4 -> 5')

print('\n' + '='*60 + '\n')

print('Дополнительный пример:')
print('Вход: [1, 2, 3, 4, 5, 6, 7, 8], k = 3')
list3 = create_linked_list([1, 2, 3, 4, 5, 6, 7, 8])
result3 = solution.reverseKGroup(list3, 3)
print(f'Результат: {linked_list_to_str(result3)}')
print('Ожидаемый вывод: 3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8')

print('\n' + '='*60 + '\n')
