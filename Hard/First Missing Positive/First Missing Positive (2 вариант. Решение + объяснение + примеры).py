# Вариант 2. Немного упрощённый.

# Импортируем тип List из модуля typing для аннотации типов.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:

    # Заводим метод, который принимает в себя ряд параметров.
    # self - ссылка на экземпляр класса (стандарт для методов класса).
    # nums: List[int] - параметр метода, список целых чисел.
    # -> int - указание, что метод возвращает целое число.
    def firstMissingPositive(self, nums: List[int]) -> int:

        # Получаем длину массива nums и сохраняем в переменную n.
        # Это делается для оптимизации, чтобы не вызывать len() многократно в циклах ниже.
        n = len(nums)

        # Начинаем первый проход по массиву. Цикл проходит по всем индексам от 0 до n-1.
        # i - текущий индекс в массиве.
        for i in range(n):

            # Внутренний цикл while. Условия для выполнения цикла:
            # 1. 1 <= nums[i] <= n - проверяет, находится ли текущий элемент в диапазоне [1, n].
            # Число должно быть положительным (> 1).
            # Число должно быть не больше длины массива (< n).
            # Это важно, потому что мы будем использовать это число как индекс.
            # 2. nums[i] != nums[nums[i] - 1] - проверяет, находится ли число на своей "правильной" позиции.
            # "Правильная" позиция для числа x - это индекс x-1.
            # Пример: число 3 должно быть на позиции 2 (индекс 2).
            # Это условие предотвращает бесконечный цикл при дубликатах.
            while 1 <= nums[i] <= n and nums[i] != nums[nums[i] - 1]:

                # Вычисляем "правильный" индекс для текущего числа.
                # Если nums[i] = 3, то correct_index = 2 (потому что число 3 должно быть
                # на позиции с индексом 2).
                correct_index = nums[i] - 1

                # Обмен местами двух элементов:
                # элемента на текущей позиции i.
                # элемента на "правильной" позиции correct_index.
                # Это помещает число на его правильное место в массиве.
                # Важно: это одновременный обмен, а не последовательное присваивание.
                nums[i], nums[correct_index] = nums[correct_index], nums[i]

        # Второй проход по массиву для поиска первого пропущенного положительного числа.
        for i in range(n):

            # Проверяем, соответствует ли значение на позиции i ожидаемому значению i + 1.
            # Если nums[i] != i + 1, значит i + 1 отсутствует в массиве.
            if nums[i] != i + 1:

                # Возвращаем первое пропущенное положительное число.
                return i + 1

        # Если все числа от 1 до n присутствуют в массиве, возвращаем n + 1.
        # Пример: для массива [1, 2, 3] длиной 3, возвращаем 4.
        return n + 1

# Заводим тестовую функцию.
def test_example():

    # Запускаем (создаём) экземпляр класса Solution.
    # После этого мы можем вызывать методы этого объекта.
    sol = Solution()

    print('Пример 1.')
    nums1 = [1, 2, 0] # 3
    print(f'Входной массив: {nums1}')
    result1 = sol.firstMissingPositive(nums1)
    print(f'Результат: {result1}') # Наименьшее положительное число, которого нет в массиве.
    print(f'Массив после обработки: {nums1}')
    print()

    print('Пример 2.')
    nums2 = [3, 4, -1, 1] # 2
    print(f'Входной массив: {nums2}')
    result2 = sol.firstMissingPositive(nums2)
    print(f'Результат: {result2}') # Наименьшее положительное число, которого нет в массиве.
    print(f'Массив после обработки: {nums2}')
    print()

    print('Пример 3.')
    nums3 = [7, 8, 9, 11, 12] # 1
    print(f'Входной массив: {nums3}')
    result3 = sol.firstMissingPositive(nums3)
    print(f'Результат: {result3}') # Наименьшее положительное число, которого нет в массиве.
    print(f'Массив после обработки: {nums3}')
    print()

    print('Пример 4.')
    nums4 = [1, 1] # 2
    print(f'Входной массив: {nums4}')
    result4 = sol.firstMissingPositive(nums4)
    print(f'Результат: {result4}') # Наименьшее положительное число, которого нет в массиве.
    print(f'Массив после обработки: {nums4}')
    print()

    print('Пример 5.')
    nums5 = [2, 1] # 3
    print(f'Входной массив: {nums5}')
    result5 = sol.firstMissingPositive(nums5)
    print(f'Результат: {result5}') # Наименьшее положительное число, которого нет в массиве.
    print(f'Массив после обработки: {nums5}')

# Запускаем всё это дело.
test_example()

# Данная версия кода более читаемая:
# 1. Используется промежуточная переменная correct_index для ясности.
# 2. Условие nums[i] != nums[nums[i] - 1] более явно показывает, что мы проверяем
# находится ли число на своём месте.
# 3. Логика идентична предыдущей версии.

# 1. Временная сложность: O(n) - каждый элемент перемещается не более одного раза.
# 2. Пространственная сложность: O(1) - используется только исходный массив.
# 3. Работает только с массивами, где можно менять элементы местами.
