# Вариант 1. Классическое решение с перестановкой чисел "на свои места".

# Импортируем тип List для аннотации типов.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод, который принимает в себя список целых чисел nums
    # и возвращает целое число - первое положительное число.
    def firstMissingPositive(self, nums: List[int]) -> int:

        # Сохраняем длину массива nums в переменную n для удобства и производительности.
        # Обворачиваем всё это в len, чтобы вычислить длину массива.
        n = len(nums)

        # Запускаем цикл по всем индексам массива от 0 до n-1.
        for i in range(n):

            # Цикл while, который выполняется при выполнении двух условий:
            # 1. Текущий элемент nums[i] находится в диапазоне [1, n].
            # То есть, это положительное число, которое потенциально можно разместить на правильной позиции.
            # 2. Элемент nums[i] находится не на своей правильной позиции.
            # Правильная позиция для числа x (где 1 ≤ x ≤ n) - это индекс x-1.
            # Условие nums[nums[i] проверяет, находится ли число на правильной позиции.
            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:

                # Меняем местами два элемента:
                # nums[i] (текущий элемент)
                # nums[nums[i] - 1] (элемент на той позиции, где должен находиться nums[i])
                # Это помещает число nums[i] на его правильную позицию в массиве.
                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

        # Второй проход по массиву для поиска первого пропущенного положительного числа.
        for i in range(n):

            # Проверяем, равно ли значение на позиции i числу i+1.
            # Если нет, значит число i+1 отсутствует в массиве.
            if nums[i] != i + 1:

                # Возвращаем первое пропущенное положительное число.
                return i + 1

        # Если все числа от 1 до n присутствуют в массиве, возвращаем n+1.
        return n + 1

# Заводим тестовую функцию.
def test_example():

    # Запускаем экземпляр класса.
    sol = Solution()

    # Пример 1.
    nums1 = [1, 2, 0]
    print(f'Вход: {nums1}')
    result1 = sol.firstMissingPositive(nums1)
    print(f'Результат: {result1}') # Наименьшее положительное число, которого нет в массиве.
    print(f'Массив после обработки: {nums1}')
    print()

    # Пример 2.
    nums2 = [3, 4, -1, 1]
    print(f'Вход: {nums2}')
    result2 = sol.firstMissingPositive(nums2)
    print(f'Результат: {result2}') # Наименьшее положительное число, которого нет в массиве.
    print(f'Массив после обработки: {nums2}')
    print()

    # Пример 3.
    nums3 = [7, 8, 9, 11, 12]
    result3 = sol.firstMissingPositive(nums3)
    print(f'Результат: {result3}') # Наименьшее положительное число, которого нет в массиве.
    print(f'Массив после обработки: {nums3}')
    print()

    # Пример 4.
    nums4 = [1, 1]
    print(f'Вход: {nums4}')
    result4 = sol.firstMissingPositive(nums4)
    print(f'Результат: {result4}') # Наименьшее положительное число, которого нет в массиве.
    print(f'Массив после обработки: {nums4}')

# Запускаем всё это добро.
test_example()

# Алгоритм выполняет точечную перестановку, а не полную сортировку.
# Он размещает только релевантные числа (1..n) на свои "правильные" позиции, игнорируя все остальные.
