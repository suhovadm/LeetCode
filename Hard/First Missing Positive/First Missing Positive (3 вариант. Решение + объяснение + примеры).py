# Вариант 3. Максимально простой, но его не примет LeetCode, т.к. нарушено требование по памяти.
# 1. Правильность ответа - да. [V]
# 2. Временная сложность - да O(n), наш алгоритм - O(n). [V]
# 3. Пространственная сложность - O(1) - наш алгоритм - O(n). [X]

# В этой версии нет импорта List и аннотации типов.

# Заводим класс Solution, как того требует LeetCode.
class Solution:

    # Заводим метод, который принимает в себя ряд параметров.
    # self - ссылка на экземпляр класса (стандартно для методов класса).
    # nums - параметр метода, принимающий список чисел.
    # Здесь нет типа List[int] и возвращаемого значения.
    def firstMissingPositive(self, nums):

        # Ключевая строка: создание множества set из элементов списка nums.
        # Множество в Python - это неупорядоченная коллекция уникальных элементов.
        # Удаляет все дубликаты из исходного массива.
        # Например: set([1, 2, 2, 3]) -> {1, 2, 3}
        s = set(nums) # O(n) памяти - НЕДОПУСТИМО.

        # Заводим переменную i со значением 1.
        # i будет использоваться для проверки последовательных положительных чисел, начиная с 1.
        i = 1

        # Цикл while, который будет выполняться, пока число i присутствует в множестве s.
        # Оператор in для множеств:
        # - проверяет наличие элемента в множестве,
        # - средняя временная сложность O(1),
        # - для списка сложность была бы O(n).
        # Цикл продолжается, пока находим очередное положительное число в массиве.
        while i in s:

            # Увеличиваем значение i на 1.
            # Если i найдено в множестве, переходим к проверке следующего числа.
            i += 1

        # Возвращаем первое положительное число i, которое НЕ найдено в множестве s.
        # Это и есть первое пропущенное положительное число.
        return i

# Алгоритм работает так:
# 1. Заводим множество (set) и удаляем дубликаты. Получаем структуру данных с быстрым поиском.
# 2. Линейный поиск: проверяем все числа по порядку: 1, 2, 3 и т.д. Пока не найдём первое отсутствующее.
# 3. Возвращаем результат в виде первого отсутствующего положительного числа.

# Заводим тестовую функцию.
def test_examples():

    # Запускаем экземпляр класса.
    sol = Solution()

    print('Пример 1.')
    nums1 = [1, 2, 0]
    print(f'Входной массив: {nums1}')
    print(f'Множество из массива: {set(nums1)}')
    result1 = sol.firstMissingPositive(nums1)
    print(f'Результат: {result1}') # 3
    print()

    print('Пример 2.')
    nums2 = [3, 4, -1, 1]
    print(f'Входной массив: {nums2}')
    print(f'Множество из массива: {set(nums2)}')
    result2 = sol.firstMissingPositive(nums2)
    print(f'Результат: {result2}') # 2
    print()

    print('Пример 3.')
    nums3 = [7, 8, 9, 11, 12]
    print(f'Входной массив: {nums3}')
    print(f'Множество из массива: {set(nums3)}')
    result3 = sol.firstMissingPositive(nums3)
    print(f'Результат: {result3}') # 1
    print()

    print('Пример 4.')
    nums4 = [1, 1]
    print(f'Входной массив: {nums4}')
    print(f'Множество из массива: {set(nums4)}')
    result4 = sol.firstMissingPositive(nums4)
    print(f'Результат: {result4}') # 2
    print()

    print('Пример 5.')
    nums5 = [2, 1]
    print(f"Входной массив: {nums5}")
    print(f"Множество из массива: {set(nums5)}")
    result5 = sol.firstMissingPositive(nums5)
    print(f'Результат: {result5}') # 3
    print()

    print('Пример 6.')
    nums6 = [1, 2, 3, 4, 5]
    print(f"Входной массив: {nums6}")
    print(f"Множество из массива: {set(nums6)}")
    result6 = sol.firstMissingPositive(nums6)
    print(f'Результат: {result6}') # 6
    print()

    print('Пример 7 (с дубликатами и отрицательными)!')
    nums7 = [0, -1, 2, 2, 1, 4, 4]
    print(f"Входной массив: {nums7}")
    print(f"Множество из массива: {set(nums7)}")
    result7 = sol.firstMissingPositive(nums7)
    print(f'Результат: {result7}') # 3

# Запускаем всё это добро.
test_examples()
