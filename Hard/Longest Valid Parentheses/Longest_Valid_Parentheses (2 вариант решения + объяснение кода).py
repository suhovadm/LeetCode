# 2 вариант решения. Более эффективен по памяти.

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Определяем метод longestValidParentheses.
    # Метод принимает строку s и возвращает целое число (длину).
    def longestValidParentheses(self, s: str) -> int:

        # max_length будет хранить максимальную найденную длину валидной подстроки. Начинаем с 0.
        max_length = 0

        # Первый проход (слева направо).

        # Заводим счётчики.
        # left - счётчик открывающих скобок '('.
        # right - счётчик закрывающих скобок ')'.
        left = right = 0

        # Цикл слева направо.
        # Проходим по строке от начала до конца.
        # i - текущий индекс.
        for i in range(len(s)):
            # Подсчёт скобок.
            # Если встречаем '(', увеличиваем left.
            if s[i] == '(':
                left += 1
            # Если встречаем ')', увеличиваем right.
            else:
                right += 1

            # Проверка баланса.
            # Если кол-во открывающих и закрывающих скобок сравнялось,
            # значит мы нашли валидную подстроку от последнего сброса до текущей позиции.
            # Её длина = 2 * right (или 2 * left).
            # Обновляем максимальную длину.
            if left == right:
                max_length = max(max_length, 2 * right)
            # Сброс при дисбалансе.
            # Если закрывающих скобок стало больше, чем открывающих,
            # это означает, что текущая подстрока стала невалидной.
            # Сбрасываем оба счётчика в 0 и начинаем поиск заново.
            elif right > left:
                left = right = 0

        # Второй проход (справа налево).
        # Сбрасываем счётчики для второго прохода.
        left = right = 0

        # Цикл справа налево.
        # Проходим по строке от конца к началу.
        # range(len(s) -1, -1, -1) - это означает: от последнего индекса до 0 включительно, с шагом -1.
        for i in range(len(s) -1, -1, -1):

            # Подсчёт скобок.
            # То же самое, но теперь идём справа налево.
            if s[i] == '(':
                left += 1
            else:
                right += 1

            # Проверка баланса.
            # Если количество скобок сравнялось.
            # Длина = 2 * left (теперь используем left, т.к. мы считаем открывающие скобки).
            # Обновляем максимум.
            if left == right:
                max_length = max(max_length, 2 * left)

            # Сброс при дисбалансе.
            # Если открывающих скобок стало больше, чем закрывающих,
            # сбрасываем счётчики и начинаем заново.
            elif left > right:
                left = right = 0

        # Возвращаем найденную максимальную длину.
        return max_length

# Почему нужно два прохода?

# -----> Рассмотрим пример "(()":

# Первый проход (слева направо):

# i=0 '(': left=1, right=0

# i=1 '(': left=2, right=0

# i=2 ')': left=2, right=1 → right > left? Нет, right < left

# Конец: left=2, right=1, left==right? Нет

# Результат первого прохода: max_length=0 ❌

# Второй проход (справа налево):

# i=2 ')': left=0, right=1

# i=1 '(': left=1, right=1 → left==right → длина=2 ✅ max_length=2

# i=0 '(': left=2, right=1 → left > right? Да → сброс

# Результат: max_length=2

# -----> Другой пример ")()())":

# Первый проход:

# Находит подстроку "()()" длиной 4 ✅

# Второй проход:

# Находит те же подстроки, подтверждая результат

# Два прохода нужны, чтобы поймать случаи, где валидные подстроки начинаются с '(' и заканчиваются
# в конце, или начинаются с начала и заканчиваются ')', которые не ловятся одним проходом.