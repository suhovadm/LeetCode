# 1 вариант решения. Простое и эффективное решение с использованием стека.

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Определяем метод longestValidParentheses, который принимает в себя ряд параметров.
    # Метод принимает строку s и возвращает целое число (длину).
    def longestValidParentheses(self, s: str) -> int:

        # Заводим стек (список) с начальным значением -1.
        # -1 служит "маркером дна" стека и помогает правильно вычислять длину с начала строки.
        # Почему -1? Если допустимая подстрока начинается с 0, то длина будет i - (-1) = i + 1.
        stack = [-1]
        # Переменная для максимальной длины.
        # Заводим переменную для хранения максимальной найденной длины.
        # Начинаем с 0 (минимально возможная длина).
        max_length = 0

        # Основной цикл.
        # Проходим по каждому символу строки, i - текущий индекс.
        for i in range(len(s)):
            # Обработка открывающей скобки.
            # Если встречаем открывающую скобку '(', добавляем её индекс в стек.
            # Это нужно для того, чтобы потом найти соответствующую закрывающую скобку.
            if s[i] == '(':
                stack.append(i)
            # Обработка закрывающей скобки.
            # Если символ - закрывающая скобка ')'.
            else:
                # Удаление последнего элемента.
                # Убираем последний индекс из стека (это может быть индекс открывающей скобки
                # или маркер -1).
                # Почему? Потому что текущая ')' "закрывает" последнюю открытую скобку.
                stack.pop()

                # Проверка на пустой стек.
                # Если после pop() стек стал пустым, значит у нас был только один элемент (-1).
                # Это означает, что текущая ')', не имеет соответствующей открывающей скобки.
                # Добавляем текущий индекс в стек как новый маркер начала.
                if not stack:
                    stack.append(i)

                # Вычисление длины.
                # Если стек не пуст, значит у нас есть начало валидной подстроки.
                # stack[-1] - индекс последнего элемента в стеке (начало валидной подстроки).
                # current_length = i - stack[-1] - длина текущей валидной подстроки.
                # Обновляем максимальную длину, если нашли больше.
                else:
                    current_length = i - stack[-1]
                    max_length = max(max_length, current_length)

        # Возвращаем найденную максимальную длину.
        return max_length