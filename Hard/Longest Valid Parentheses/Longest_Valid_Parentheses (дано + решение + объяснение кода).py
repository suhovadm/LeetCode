# Longest Valid Parentheses

# Учитывая строку, содержащую только символы '(' и ')', верните длину самой длинной допустимой
# (правильно сформированной) подстроки круглых скобок.

# Пример 1:
# входные данные: s = "(()"
# Результат: 2
# Пояснение: самая длинная допустимая подстрока скобок это "()".

# Пример 2:
# Входные данные: s = ")()())"
# Результат: 4
# Пояснение: самая длинная допустимая подстрока скобок это "()()".

# Пример 3:
# Входные данные s = ""
# Результат: 0

# Ограничения:
# 0 <= длина строки <= 3 * 10⁴
# s[i] это либо '(', либо ')'

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Определяем метод longestValidParentheses, который принимает в себя ряд параметров.
    # Метод принимает строку s и возвращает целое число (длину).
    def longestValidParentheses(self, s: str) -> int:

        # max_length будет хранить максимальную найденную длину валидной подстроки. Начинаем с 0.
        max_length = 0

        # Первый проход (слева направо).

        # Заводим счётчики.
        # left - счётчик открывающих скобок '('.
        # right - счётчик закрывающих скобок ')'.
        left = right = 0

        # Цикл слева направо.
        # Проходим по строке от начала до конца.
        # i - текущий индекс.
        for i in range(len(s)):
            # Подсчёт скобок.
            # Если встречаем '(', увеличиваем left.
            if s[i] == '(':
                left += 1
            # Если встречаем ')', увеличиваем right.
            else:
                right += 1

            # Проверка баланса.
            # Если кол-во открывающих и закрывающих скобок сравнялось,
            # значит мы нашли валидную подстроку от последнего сброса до текущей позиции.
            # Её длина = 2 * right (или 2 * left).
            # Обновляем максимальную длину.
            if left == right:
                max_length = max(max_length, 2 * right)
            # Сброс при дисбалансе.
            # Если закрывающих скобок стало больше, чем открывающих,
            # это означает, что текущая подстрока стала невалидной.
            # Сбрасываем оба счётчика в 0 и начинаем поиск заново.
            elif right > left:
                left = right = 0

        # Второй проход (справа налево).
        # Сбрасываем счётчики для второго прохода.
        left = right = 0

        # Цикл справа налево.
        # Проходим по строке от конца к началу.
        # range(len(s) -1, -1, -1) - это означает: от последнего индекса до 0 включительно, с шагом -1.
        for i in range(len(s) -1, -1, -1):

            # Подсчёт скобок.
            # То же самое, но теперь идём справа налево.
            if s[i] == '(':
                left += 1
            else:
                right += 1

            # Проверка баланса.
            # Если количество скобок сравнялось.
            # Длина = 2 * left (теперь используем left, т.к. мы считаем открывающие скобки).
            # Обновляем максимум.
            if left == right:
                max_length = max(max_length, 2 * left)

            # Сброс при дисбалансе.
            # Если открывающих скобок стало больше, чем закрывающих,
            # сбрасываем счётчики и начинаем заново.
            elif left > right:
                left = right = 0

        # Возвращаем найденную максимальную длину.
        return max_length