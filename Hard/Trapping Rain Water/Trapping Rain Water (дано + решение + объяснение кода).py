# Дано n неотрицательных чисел, представляющих карту высот,
# где ширина каждого столбца равна 1.
# Вычислите, сколько воды может задержаться после дождя.

# Пример 1:
# Ввод: height = [0,1,0,2,1,0,1,3,2,1,2,1]
# Вывод: 6
# Объяснение: представленная карта высот (чёрные секции) соответствует массиву
# [0,1,0,2,1,0,1,3,2,1,2,1]. В этом случае удерживается 6 едениц дождевой воды (синие секции).

# Пример 2.
# Ввод: height = [4,2,0,3,2,5]
# Вывод: 9

# Ограничения:
# n == height.length
# 1 <= n <= 2 * 10^4
# 0 <= height[i] <= 10^5

# Импортируем List для аннотации типов.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:

    # Заводим метод trap.
    # Метод trap принимает список высот height и возвращает целое число (объём воды).
    def trap(self, height: List[int]) -> int:

        # Проверка на пустой массив.
        # Если массив пуст, воды быть не может - возвращаем 0.
        if not height:
            return 0

        # Заводим указатели и максимумы по которым будем ориентироваться.
        # left - указатель на начало массива, т.е. 0
        # right - указатель на конец массива, последний индекс.
        left, right = 0, len(height) - 1

        # left_max - максимальная высота, встреченная слева (начинаем с первого элемента).
        # right_max - максимальная высота, встреченная справа (начинаем с последнего элемента).
        left_max, right_max = height[left], height[right]

        # water - аккумулятор для подсчёта объема воды (изначально равен нулю).
        water = 0

        # Основной цикл.
        # Пока указатели не встретятся (или не пересекутся), продолжаем обработку.
        while left < right:

            # Логика левой стороны.
            # if left_max < right_max - сравниваем максимальные высоты с обеих сторон.
            # Вода ограничена минимальной из двух максимальных высот.
            # Если left_max < right_max, значит вода слева ограничена left_max.
            if left_max < right_max:

                # Двигаем левый указатель вправо.
                left += 1

                # Обновляем максимум слева.
                # Берём максимальное значение между текущим left_max и новой высотой.
                left_max = max(left_max, height[left])

                # Добавляем воду.
                # left_max - height[left] - вычисляем, сколько воды может удержаться над текущей позицией.
                # max(0, ...) - защита от отрицательных значений.
                water += max(0, left_max - height[left])

            # Логика обработки правой стороны.
            else:

                # Здесь всё аналогично левой стороне, но тут мы двигаем правый указатель влево.
                right -= 1
                right_max = max(right_max, height[right])
                water += max(0, right_max - height[right])

        # Возвращаем общее количество собранной воды.
        return water

# Таким образом, нам нужно просто сравнить входные данные функции
# с индексами алгоритма - 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 и т.д.