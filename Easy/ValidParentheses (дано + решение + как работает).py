# Дана строка s, которая содержит только символы '(', ')', '{', '}', '[' и ']'.
# Определите, является ли входная строка валидной.

# Входная строка является валидной, если:
# 1. Открывающие скобки должны быть закрыты скобками того же типа.
# 2. Открывающие скобик должны быть закрыты в правильном порядке.
# 3. Каждая закрывающая скобка имеет соответствующую открывающую скобку того же типа.

# Пример 1:
# Ввод: s = '()'
# Вывод: true

# Пример 2:
# Ввод: s = '()[]{}'
# Вывод: true

# Пример 3:
# Ввод: s = '(]'
# Вывод: false

# Пример 4:
# Ввод: s = '([])'
# Вывод: true

# Пример 5:
# Ввод: s = '([)]'
# Вывод: false

class Solution:
    def isValid(self, s: str) -> bool:

        brackets_map = {
                        ')': '(',
                        '}': '{',
                        ']': '['
                        }

        stack = []

        for char in s:
            if char in brackets_map.values():
                stack.append(char)
            elif char in brackets_map:
                if not stack or stack.pop() != brackets_map[char]:
                    return False

        return not stack

# Как это работает?
# 1. Словарь соответствий: brackets_map хранит соответствие закрывающих скобок их открывающим парам.
# 2. Стек: используется для отслеживания открывающих скобок в правильном порядке.
# 3. Алгоритм:
#   - идём по строке символ за символом.
#   - если встречаем открывающую скобку - кладём её в стек.
#   - если встречаем закрывающую скобку:
#   проверяем, есть ли что-то в стеке (чтобы не было ситуации ")" без открывающей).
#   проверяем, соответствует ли последняя открывающая скобка текущей закрывающей.
#   если нет - сразу возвращаем False.
# В конце проверяем, что стек пуст (все открытые скобки были закрыты).

# '()[]{}' - валидно.
# '([)]' - невалидно (нарушен порядок закрытия).
# '(' - невалидно (осталась открытая скобка).
