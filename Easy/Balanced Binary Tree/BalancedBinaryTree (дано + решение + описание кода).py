# Задача.
# Дано бинарное дерево. Определите, является ли оно сбалансированным по высоте.

# Бинарное дерево считается сбалансированным по высоте, если для каждого узла разница высот
# левого и правого поддеревьев не превышает 1.

# Пример 1.
# Вход: root = [3,9,20,null,null,15,7]
# Выход: true

# Пример 2:
# Вход: root = [1,2,2,3,3,null,null,4,4]
# Выход: false

# Пример 3:
# Вход: root = []
# Выход: true

# Ограничения: количество узлов в дереве находится в диапазоне [0, 5000]

# Рекурсивно считаем высоту поддеревьев.
# Если где-то разница высот больше 1 - сразу возвращаем "несбалансировано".

# Почему данное решение считается эффективным?
# 1. Каждый узел посещается 1 раз.
# 2. Высота считается "снизу вверх".
# 3. Как только дерево становится несбалансированным - вычисления останавливаются.

# Импорт типов. Optional[TreeNode] означает либо объект TreeNode, либо None.
# Для бинарных деревьев - это означает: пустое дерево -> None, отсутствующий потомок -> None.
# Это подсказка для типов.
from typing import Optional

# Заводим класс TreeNode. Это стандартное описание узла бинарного дерева.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):

        # val - значение узла.
        # left - ссылка на левое поддерево.
        # right - ссылка на правое поддерево.

        # Пример узла:
        # node = TreeNode(5)

        # Или же с потомками:
        # node = TreeNode(5, TreeNode(3), TreeNode(7))
        self.val = val
        self.left = left
        self.right = right

# Заводим класс Solution.
# root - корень дерева, может быть TreeNode, либо None.
# Метод должен вернуть True - дерево сбалансировано, False - нет.
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:

        # Заводим вложенную вспомогательную рекурсивную функцию, которая
        # возвращает высоту поддерева, или -1, если поддерево несбалансировано.
        def height(node):

            # Базовый случай рекурсии.
            # Если node is None:
            # - это пустое дерево,
            # - его высота равна 0,
            # - пустое дерево всегда сбалансировано.
            if not node:
                return 0

            # Высота левого поддерева.
            # Рекурсивно считаем высоту левого поддерева.
            # left может быть: 0, 1, 2, ... - нормальная высота.
            # -1 - левое поддерево несбалансировано.
            left = height(node.left)

            # Ранний выход (левое поддерево).
            # Если левое поддерево уже несбалансировано,
            # то нет смысла проверять дальше.
            # Сразу возвращаем -1 вверх по рекурсии.
            # Это делает алгоритм быстрым.
            if left == -1:
                return -1

            # Высота правого поддерева. Аналогично для правой стороны.
            right = height(node.right)

            # Ранний выход (правое поддерево).
            # Если правое поддерево несбалансировано, сразу прерываем вычисления.
            if right == -1:
                return -1

            # Проверка баланса текущего узла.
            # Считаем разницу высот.
            # Если больше 1 -> дерево несбалансировано.
            # Возвращаем -1 как сигнал ошибки.
            if abs(left - right) > 1:
                return -1

            # Возврат высоты текущего узла.
            # Если всё хорошо:
            # высота текущего узла = максимальная высота потомков + 1; +1 - это сам текущий узел.
            return max(left, right) + 1

        # Запускаем проверку от корня.
        # Если вернулось -1 -> дерево несбалансировано.
        # Иначе -> сбалансировано.
        return height(root) != -1