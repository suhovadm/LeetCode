# Дан массив целых чисел nums, отсортированный в неубывающем порядке.
# Удалите дубликаты на месте (in-place) так, чтобы каждый уникальный элемент
# встречался только один раз.
# Относительный порядок элементов должен быть сохранён.

# Пусть количество уникальных элементов в nums равно k.
# После удаления дубликатов верните количество уникальных элементов k.

# Первые k элементов массива nums должны содержать уникальные числа в
# отсортированном порядке. На элменты, следующие за индексом k - 1,
# можно не обращать внимания.

# Проверяющая система:
# Решение будет проверяться следующим кодом:
# int[] nums = [...]; // Входной массив
# int[] expectedNums = [...]; // Ожидаемый ответ правильной длины

# int k = removeDuplicates(nums); // Вызов вашей реализации

# assert k == expectedNums.length;
# for (int i = 0; i < k; i++) {
#      assert nums[i] == expectedNums[i];
# }
# Если все утверждения (assertions) выполняются, ваше решение будет принято.

# Пример 1:
# Ввод: nums = [1, 1, 2]
# Вывод: 2, nums = [1, 2, _]
# Пояснение: Ваша функция должна вернуть k = 2, при этом первые два элемента
# массива nums должны быть 1 и 2 соответственно.
# Не имеет значения, что останется за пределами возвращённого значения k
# (поэтому на этих местах указаны прочерки).

# Пример 2:
# Ввод: nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
# Вывод: 5, nums = [0, 1, 2, 3, 4, _, _, _, _, _]
# Пояснение: ваша функция должна вернуть k = 5, при этом первые пять
# элементов массива nums должны быть 0, 1, 2, 3 и 4 соответственно.
# Не имеет значения, что останется за пределами возвращённого значения k
# (поэтому на этих местах указаны прочерки).
