# Импортируем List для аннотации типов.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Определяем метод removeDuplicates, который принимает список nums и возвращает целое число.
    def removeDuplicates(self, nums: List[int]) -> int:

        # Проверяем, что список не пустой.
        # Если список пуст, возвращаем 0 (нет уникальных элементов).
        if not nums:
            return 0

        # Заводим указатель k, который будет:
        # а) считать количество уникальных элементов,
        # б) указывать позицию для записи следующего уникального элемента.
        k = 0

        # Проходимся по всем элементам исходного списка.
        for num in nums:

            # Условие для записи элемента:
            # 1) k == 0: это первый элемент, всегда уникальный.
            # 2) num != nums[k - 1]: текущий элемент отличается от
            # последнего записанного уникального элемента...
            if k == 0 or num != nums[k - 1]:

                # Записываем текущий элемент на позицию k
                # Это работает, потому что мы используем тот же список.
                nums[k] = num

                # Увеличиваем счётчик уникальных элементов.
                k += 1

        # Возвращаем количество уникальных элементов.
        return k

# Точка входа в программу, запускаем программу.
if __name__ == "__main__":

    # Исходный массив.
    nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]

    print('Исходный массив:', nums)
    print('Длина исходного массива:', len(nums))
    print('-' * 40)

    # Создаём экземпляр класса.
    solution = Solution()

    # Вызываем метод.
    k = solution.removeDuplicates(nums)

    print('Количество уникальных элементов (k):', k)
    print('Первые k элементов массива:', nums[:k])
    print('Весь массив после обработки:', nums)
    print('-' * 40)

    # Дополнительные примеры.
    test_cases = [
        [1, 1, 2],
        [1, 1, 1],
        [1, 2, 3],
        []
    ]

    for i, test_nums in enumerate(test_cases):
        print(f'\nПример {i + 1}: {test_nums}')
        if test_nums:
            k_test = solution.removeDuplicates(test_nums.copy()) # Копируем, чтобы не менять оригинал.
            print(f'k = {k_test}, первые k элементов: {test_nums[:k_test]}')
        else:
            print('Пустой массив, k = 0')

# Как работает алгоритм на примере nums = [0,0,1,1,1,2,2,3,3,4]:

# Шаг 1: k = 0, берем num = 0
# k == 0 → true → nums[0] = 0, k = 1

# Шаг 2: k = 1, берем num = 0
# num != nums[0]? 0 != 0 → false → ничего не делаем

# Шаг 3: k = 1, берем num = 1
# num != nums[0]? 1 != 0 → true → nums[1] = 1, k = 2

# Шаг 4: k = 2, берем num = 1
# num != nums[1]? 1 != 1 → false → ничего не делаем

# Шаг 5: k = 2, берем num = 1
# num != nums[1]? 1 != 1 → false → ничего не делаем

# Шаг 6: k = 2, берем num = 2
# num != nums[1]? 2 != 1 → true → nums[2] = 2, k = 3

# Шаг 7: k = 3, берем num = 2
# num != nums[2]? 2 != 2 → false → ничего не делаем

# Шаг 8: k = 3, берем num = 3
# num != nums[2]? 3 != 2 → true → nums[3] = 3, k = 4

# Шаг 9: k = 4, берем num = 3
# num != nums[3]? 3 != 3 → false → ничего не делаем

# Шаг 10: k = 4, берем num = 4
# num != nums[3]? 4 != 3 → true → nums[4] = 4, k = 5

# Итог: k = 5, список изменён на [0, 1, 2, 3, 4, 2, 2, 3, 3, 4] (первые 5 элементов уникальы).

# Алгоритм работает "на месте" (in-place), т.е. не создаёт новый список.
# Сложность O(n) по времени (один проход по массиву).
# Сложность O(1) по памяти (не использует дополнительных структур данных).
# Использует два указателя: один для чтения (num в цикле), другой для записи (k).
