# Даны два целочисленных массива nums1 и nums2, отсортированные
# в неубывающем порядке, и два целых числа m и n,
# представляющие количество элементов в nums1 и nums2 соответственно.

# Необходимо объединить nums1 и nums2 в один массив, отсортированный в неубывающем порядке.

# Финальный отсортированный массив не должен возвращаться функцией,
# а должен быть сохранен внутри массива nums1. Для этого длина nums1
# равна m + n, где первые m элементов обозначают элементы, которые нужно объединить,
# а последние n элементов установлены в 0 и должны игнорироваться. Длина nums2 равна n.

# Пример 1:
# Ввод: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
# Вывод: [1,2,2,3,5,6]
# Объяснение: Объединяемые массивы — это [1,2,3] и [2,5,6].
# Результат слияния — [1,2,2,3,5,6], где подчеркнутые элементы взяты из nums1.

# Пример 2:
# Ввод: nums1 = [1], m = 1, nums2 = [], n = 0
# Вывод: [1]
# Объяснение: Объединяемые массивы — это [1] и [].
# Результат слияния — [1].

# Пример 3:
# Ввод: nums1 = [0], m = 0, nums2 = [1], n = 1
# Вывод: [1]
# Объяснение: Объединяемые массивы — это [] и [1].
# Результат слияния — [1].
# Обратите внимание, что поскольку m = 0, в nums1 нет элементов.
# Ноль здесь только для того, чтобы результат слияния поместился в nums1.

# Импортируем тип List из модуля typing.
# Это нужно для аннотации типов (указания, что nums1 и nums2 - это списки чисел).
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:

    # Определяем метод merge с четырьмя параметрами:
    # nums1 - первый список для слияния. List[int] - целые числа.
    # m - количество действительных элементов в nums1.
    # nums2 - второй список для слияния. List[int] - целые числа.
    # n - количество действительных элементов в nums2.
    # def merge(...) -> None говорит нам о том, что метод ничего не возвращает,
    # только изменяет nums1.
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:

        # Цикл for, который выполняется n раз (по количеству элементов в nums2)
        # i принимает значения от 0 до n-1.
        # Копирует все n элементов из nums2.
        for i in range(n):

            # Копируем элемент из nums2 в конец nums1
            # nums1[m + i] - обращаемся к позиции в nums1 сразу после последнего
            # действительного элемента.
            # nums2[i] - берем i-й элемент из nums2
            # Например: если m=3, то копируем nums2[0] в nums1[3], nums2[1] в nums1[4] и т.д.
            # Заполняет "пустые" нули в конце nums1 элементами из nums2.
            nums1[m + i] = nums2[i]

        # Сортируем весь список nums1 целиком.
        # Метод sort() сортирует список "на месте", т.е. in-place.
        # После этой строки все элементы в nums1 будут расположены в порядке возрастания.
        # Простой способ отсортировать объединённый массив.
        nums1.sort()

# Запуск основного класса Solution() через переменную.
solution = Solution()

# Вывод примеров в консоль.
print('Пример 1:')
nums1 = [1, 2, 3, 0, 0, 0]
m = 3
nums2 = [2, 5, 6]
n = 3
print(f'До:     nums1 = {nums1}')
print(f'        nums2 = {nums2}')
solution.merge(nums1, m, nums2, n)
print(f'После:  nums1 = {nums1}')
print()

print('Пример 2:')
nums1 = [1]
m = 1
nums2 = []
n = 0
print(f'До:     nums1 = {nums1}')
print(f'        nums2 = {nums2}')
solution.merge(nums1, m, nums2, n)
print(f'После:  nums2 = {nums1}')
print()

print('Пример 3:')
nums1 = [0]
m = 0
nums2 = [1]
n = 1
print(f'До:     nums1 = {nums1}')
print(f'        nums2 = {nums2}')
solution.merge(nums1, m, nums2, n)
print(f'После:  nums1 = {nums1}')
