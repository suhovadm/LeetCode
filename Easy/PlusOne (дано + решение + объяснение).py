# Дано большое целое число, представленное в виде массива digits, где каждый элемент
# digits[i] является i-й цифрой числа. Цифры упорядочены от наиболее значимой к наименее
# значимой слева направо. Большее число не содержит ведущих нулей.

# Увеличьте большое число на единицу и верните результирующий массив цифр.

# Пример 1:
# Ввод: digits = [1,2,3]
# Вывод: [1,2,4]
# Объяснение: массив представляет число 123.
# Увеличение на единицу даёт 123 + 1 = 124.
# Таким образом, результат должен быть [1,2,4].

# Пример 2:
# Ввод: digits = [4,3,2,1]
# Вывод: [4,3,2,2]
# Объяснение: массив представляет число 4321.
# Увеличение на единицу даёт 4321 + 1 = 4322.
# Таким образом результат должен быть [4,3,2,2]

# Пример 3:
# Ввод: digits = [9]
# Вывод: [1,0]
# Объяснение: массив представляет число 9.
# Увеличение на единицу даёт 9 + 1 = 10.
# Таким образом, результат должен быть [1,0].

from typing import List

class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:

        for i in range(len(digits) -1, -1, -1):

            if digits[i] < 9:
                digits[i] += 1
                return digits
            digits[i] = 0

        return [1] + digits

# Объяснение алгоритма:
# 1. Мы проходим массив с конца (от младших разрядов к старшим).
# 2. Если текущая цифра меньше 9, просто увеличиваем её на 1 и сразу возвращаем результат.
# 3. Если цифра равна 9, меняем её на 0 и продолжаем проверять следующую цифру слева.
# 4. Если все цифры были 9 (например 999 -> 000), то добавляем 1 в начало массива.
# Пример работы:
# [1,2,3] -> [1,2,4] (увеличиваем последнюю цифру).
# [1,2,9] -> [1,3,0] (перенос разряда. Двойка стала тройкой, девятка превратилась в ноль).
# [9,9] -> [1,0,0] (увеличилас длина числа).

# Этот подход работает за O(n) времени, где n - количество цифр, и использует O(1) дополнительной
# памяти (кроме случая, когда нужно увеличить длину массива).
