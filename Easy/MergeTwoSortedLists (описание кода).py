# Импортируем Optional из библиотеки typing.
# Это нужно для указания типов в аннотациях функций.
from typing import Optional

# Заводим класс ListNode для узла связанного списка.
class ListNode:

    # Заводим конструктор с параметрами.
    # Каждый узел имеет:
    # val - значение узла, по умолчанию 0.
    # next - ссылка на следующий узел, по умолчанию None.
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# Определяем класс Solution с методом mergeTwoLists.
class Solution:

    # Метод принимает два необязательных аргумента типа ListNode и возвращает ListNode или None.
    # Optional означает, что любой из этих параметров может быть None, т.е. пустой список.
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:

        # Создаём "фиктивный" узел.
        # Зачем он нужен? Чтобы упростить логику:
        # - не нужно отдельно обрабатывать случай, когда результирующий список пустой.
        # - Всегда есть узел, к которому можно прицепить следующий.
        # - Позволяет единообразно обрабатывать добавление элементов.
        dummy = ListNode()

        # Создаём указатель current, который всегда указывает на последний узел в новом списке.
        # Изначально указывает на dummy, так как список пока пустой.
        current = dummy

        # Цикл выполняется, пока оба списка не пустые.
        # Если хотя бы один список стал пустым (None), выходим из цикла.
        while list1 and list2:

            # Если значение в list1 меньше или равно значению в list2:
            # - присоединяем узел из list1 к результату: current.next = list1
            # - перемещаем указатель list1 на следующий узел: list1 = list1.next
            if list1.val <= list2.val:
                current.next = list1
                list1 = list1.next

            # Иначе (если значение в list2 меньше):
            # - присоединяем узел из list2 к результату: current.next = list2
            # - перемещаем указатель list2 на следующий узел: list2 = list2.next
            else:
                current.next = list2
                list2 = list2.next

            # Перемещаем указатель current на только что добавленный узел.
            # Теперь current снова указывает на последний узел в новом списке.
            current = current.next

        # После выхода из цикла один из списков (или оба) стал пустым.
        # Эта строка добавляет остаток непустого списка:
        # - если list1 не пустой, прицепляем остаток list1
        # - иначе прицепляем остаток list2 (даже если он пустой - это нормально).
        current.next = list1 if list1 else list2

        # Возвращаем начало реального списка.
        # dummy.next указывает на первый реальный узел, так как dummy был фиктивным.
        return dummy.next
