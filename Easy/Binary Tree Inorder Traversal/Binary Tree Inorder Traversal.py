# Дан корень бинарного дерева. Верните инфиксный обход значений его узлов.
# Инфиксный обход выполняется в следующем порядке:
# 1. Левое поддерево.
# 2. Текущий узел.
# 3. Правое поддерево.

# Пример 1:
# Ввод: root = [1, null, 2, 3]
# Вывод: [1, 3, 2]
# Пояснение: сначала посещается левое поддерево, затем корень, затем правое поддерево.

# Пример 2:
# Ввод: root = [1, 2, 3, 4, 5, null, 8, null, null, 6, 7, 9]
# Вывод: [4, 2, 6, 5, 7, 1, 3, 9, 8]

# Пример 3:
# Ввод: root = []
# Вывод: []

# Пример 4:
# Ввод: root = [1]
# Вывод: [1]

# Ограничения:
# Количество узлов в дереве находится в диапазоне [0, 100].
# Значение каждого узла: -100 ≤ Node.val ≤ 100.

# Импортируем библиотеки.
# List[int] - означает "список целых чисел", Optional[TreeNode] - означает:
# либо TreeNode, либо None (пустое дерево).
# Это подсказки типов, они не влияют на работу программы, но помогают читать код и ловить ошибки.
from typing import Optional, List

# Заводим класс TreeNode для узла бинарного дерева.
# val - значение узла.
# left - ссылка на левый дочерний узел.
# right - ссылка на правый дочерний узел.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val # сохраняем значение узла.
        self.left = left # сохраняем ссылку на левый узел.
        self.right = right # сохраняем ссылку на правый узел.

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод inorderTraversal.
    # root - корень бинарного дерева. Он может быть:
    # TreeNode - дерево существует. None - дерево пустое.
    # Метод возвращает List[int] - список значений узлов.
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:

        # Заводим список для результата.
        # В него будем по порядку добавлять значения узлов. В конце именного его мы и вернём.
        result = []

        # Вложенный метод (функция) dfs. dfs - это Depth First Search (поиск в глубину).
        # Функция принимает текущий узел node и обходит дерево рекурсивно.
        # Почему данная функция внутри? Чтобы иметь доступ к result и чтобы не передавать
        # result каждый раз как параметр.
        def dfs(node):

            # Если node равен None, значит узла нет.
            # Останавливаем текущий вызов функции.
            # Это базовый случай рекурсии, без него будет ошибка.
            if not node:
                return

            # Сначала идём влево. Вызываем dfs для левого потомка.
            # Если его нет - сразу вернёмся.
            dfs(node.left)

            # Когда левое поддерево полностью обработано,
            # добавляем значение текущего узла в result.
            result.append(node.val)

            # Правое поддерево.
            # После текущего узла идём вправо. Аналогично обходим правое поддерево.
            dfs(node.right)

        # Запускаем рекурсивный обход. Начинаем с корня дерева.
        # Если root = None:
        # dfs(None) сразу вернёт None. result останется пустым.
        dfs(root)

        # Возвращаем результат, т.е. список значений.
        # В правильном порядке: левый -> узел -> правый.
        return result

# Как это выглядит логически:
# Для каждого узла:
# 1. Обойти левое поддерево.
# 2. Записать значение узла.
# 3. Обойти правое поддерево.

# Пример простого дерева:
#     1
#      \
#       2
#      /
#     3

# Порядок вызовов:
# dfs(1)
#  └─ dfs(None)
#  └─ add 1
#  └─ dfs(2)
#      └─ dfs(3)
#          └─ add 3
#      └─ add 2

# --------------------------------------------------------

# Пример 1: root = [1, null, 2, 3]
root1 = TreeNode(1)
root1.right = TreeNode(2)
root1.right.left = TreeNode(3)

print("Пример 1:", Solution().inorderTraversal(root1))

# --------------------------------------------------------

# Пример 2: root = [1,2,3,4,5,null,8,null,null,6,7,9]

root2 = TreeNode(1)
root2.left = TreeNode(2)
root2.right = TreeNode(3)

root2.left.left = TreeNode(4)
root2.left.right = TreeNode(5)

root2.left.right.left = TreeNode(6)
root2.left.right.right = TreeNode(7)

root2.right.right = TreeNode(8)
root2.right.right.left = TreeNode(9)

print("Пример 2:", Solution().inorderTraversal(root2))

# --------------------------------------------------------

# Пример 3: root = []
print("Пример 3:", Solution().inorderTraversal(None))

# --------------------------------------------------------

# Пример 4: root = [1]
root4 = TreeNode(1)
print("Пример 4:", Solution().inorderTraversal(root4))

# --------------------------------------------------------
