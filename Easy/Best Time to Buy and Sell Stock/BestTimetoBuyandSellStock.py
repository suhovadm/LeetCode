# Импортируем класс List из модуля typing для аннотации типов.
# Это помогает указать, что параметр prices должен быть списком целых чисел.
from typing import List

# Заводим класс Solution.
class Solution:
    # Определяем метод maxProfit, который принимает в себя ряд параметров.
    # self - ссылка на экземпляр класса.
    # prices: List[int] - список целых чисел.
    # -> int - указывает, что функция возвращает целое число.
    def maxProfit(self, prices: List[int]) -> int:

        # Проверка граничных случаев.
        # not prices - проверяем, является ли список пустым, или ложным значением.
        # len(prices) < 2 - проверяем, содержит ли список менее 2 элементов.
        if not prices or len(prices) < 2:

            # Если любое из этих истинно, возвращаем 0, потому что:
            # если список пуст, нет данных для анализа
            # если только один элемент, невозможно совершить транзакцию (купить и продать в разные дни)
            return 0

        # Заводим переменную min_prices, задача которой отслеживать минимальную цену,
        # которую мы видели до текущего момента.
        # Почему именно первый элемент? Мы начинаем с первого дня как потенциальной точки покупки.
        min_price = prices[0]

        # Заводим переменную max_profit со значением 0.
        # Её задача отслеживать максимальную прибыль, которую можно получить.
        # Если прибыль невозможна, мы вернём 0.
        max_profit = 0

        # Заводим цикл, который перебирает все элементы списка prices, начиная со второго элемента (индекс 1).
        # prices[1:] - создаёт срез списка со второго элемента до конца.
        # current_price - цена акции в текущий день цикла.
        # Почему начинаем со второго элемента? Мы уже использовали первый элемент
        # как начальное значение min_price.
        for current_price in prices[1:]:

            # Проверяем, является ли цена текущего дня меньше, чем самая низкая цена,
            # которую мы видели до сих пор (min_price).
            if current_price < min_price:

                # Если текущая цена действительно ниже min_price, то:
                # обновляем min_price до значения current_price.
                # ! Если мы нашли наиболее низкую цену, это становится лучшей
                # точкой для потенциальной покупки в будущем.
                min_price = current_price

            # Если текущая цена НЕ ниже min_price, т.е. равна или выше,
            # это означает, что потенциально может быть прибыль, если мы продадим сегодня.
            else:

                # Вычисляем, какую прибыль мы получим, если
                # купим по самой низкой цене, которую видели до сих пор (min_price)
                # и продадим по текущей цене (current_price).
                current_profit = current_price - min_price

                # Сравниваем вычисленную текущую прибыль с максимальной прибылью,
                # которую мы нашли до сих пор.
                if current_profit > max_profit:

                    # Если текущая прибыль больше максимальной,
                    # обновляем max_profit до значения current_profit.
                    # ! Таким образом мы нашли новую лучшую возможность для совершения сделки.
                    max_profit = current_profit

        # Возвращаем максимальную прибыль, которую можно было получить.
        # Если прибыль невозможна, вернётся 0, т.е. начальное значение.
        return max_profit