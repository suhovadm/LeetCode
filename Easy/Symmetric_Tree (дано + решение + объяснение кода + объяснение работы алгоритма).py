# Дано корень двоичного дерева. Проверьте, является ли дерево зеркальным отражением самого
# себя (т.е. симметричным относительно центра).

# Пример 1:
# Ввод: root = [1,2,2,3,4,4,3]
# Вывод: true

# Пример 2:
# Ввод: root = [1,2,2,null,3,null,3]
# Вывод: false

# Ограничения:
# Количество узлов в дереве находится в диапазоне [1,1000].
# -100 <= Node.val <= 100.

# Заводим класс, представляющий собой узел двоичного дерева.
class TreeNode:
    # Заводим конструктор с параметрами.
    # val=0 - значение узла (по умолчанию 0).
    # left=None - ссылка на левый дочерний узел (по умолчанию None).
    # right=None - ссылка на правый дочерний узел (по умолчанию None).
    def __init__(self, val=0, left=None, right=None):

        # Атрибуты объекта.
        self.val = val # Хранит значение узла.
        self.left = left # Хранит ссылку на левого потомка.
        self.right = right # Хранит ссылку на правого потомка.

# Заводим класс Solution, как того требует LeetCode.
class Solution:

    # Метод, который принимает корень дерева и возвращает True, если дерево симметрично, иначе False.
    def isSymmetric(self, root):

        # Проверка пустого дерева.
        # if not root - проверяет, является ли root пустым, то есть None.
        # Если дерево пустое (нет корня), то оно технически симметрично. Это крайний случай,
        # который также покрывает пустое дерево с 0 узлов.
        if not root:
            return True

        # Запуск рекурсивной проверки.
        # Если дерево не пустое, вызываем вспомогательную функцию check, передавая ей:
        # root.left - левое поддерево от корня.
        # root.right - правое поддерево от корня.
        # Дерево симметрично, если левое и правое поддеревья являются зеркальными отражениями
        # друг друга.
        return self.check(root.left, root.right)

    # Вспомогательная рекурсивная функция.
    # check - рекурсивная функция, которая сравнивает два узла на зеркальность.
    # Принимает в себя 2 параметра:
    # left - узел из левой части дерева.
    # right - узел из правой части дерева.
    def check(self, left, right):

        # Базовый случай: оба узла пустые.
        # if not left and not right - проверяет, являются ли оба узла None.
        # Если оба узла отсутствуют (достигли конца веток одновременно), то эта часть
        # дерева симметрична.
        # Пример: в дереве [1,2,2] для узлов 2 (левый) и 2 (правый) их потомки будут
        # None - это симметрично.
        if not left and not right:
            return True

        # Базовый случай: один узел пустой, другой нет.
        # if not left or not right - проверяет, является ли хотя бы один из узлов None,
        # а другой - нет.
        # Если один узел существует, а другого нет, структура дерева несимметрична.
        # Пример: в дереве [1,2,null] левый потомок существует (2), а правый - None.
        # Это несимметрично.
        if not left or not right:
            return False

        # Проверка значений узлов.
        # Если оба узла существуют, сравниваем их значения (left.val и right.val).
        # Если значения разные, узлы несимметричны.
        # Пример: в дереве [1,2,3] значения 2 и 3 разные - несимметрично.
        if left.val != right.val:
            return False

        # Рекурсивный вызов для потомков.
        # Чтобы два поддерева были зеркальными:
        # 1. Левый потомок левого узла должен быть зеркальным правому потомку правого узла:
        # - left.left сравнивается с right.right.
        # - Это внешние узлы относительно центра.
        # 2. Правый потомок левого узла должен быть зеркальным левому потомку правого узла:
        # left.right сравнивается с right.left.
        # - Это внутренние узлы относительно центра.
        # Оператор and гарантирует нам, что оба сравнения должны вернуть true для симметричности
        # текущих поддеревьев.
        return self.check(left.left, right.right) and self.check(left.right, right.left)

# 1. Основная функция isSymmetric() проверяет корень дерева.
# 2. Вспомогательная функция check() рекурсивно сравнивает пары узлов:
# - левый дочерний узел левого поддерева с правым дочерним узлом правого поддерева.
# - правый дочерний узел левого поддерева с левым дочерним узлом правого поддерева.
# 3. Базовые случаи рекурсии:
# - если оба узла None - симметрично.
# - если только один узел None - не симметрично.
# - если значения узлов разные - не симметрично.
# Пример работы:
# - для дерева [1,2,2,3,4,4,3] функция вернёт True.
# - для дерева [1,2,2,null,3,null,3] функция вернёт False.
# Сложность: O(n) по времени и O(h) по памяти, где n - количество узлов, h - высота дерева.

# Визуализация работы на примере:

    #     1
    #    / \
    #   2   2
    #  / \ / \
    # 3  4 4  3

    # Вызовы функции check:
    # 1. check(2, 2) - корневые левый и правый.
    # Значения равны (2 == 2)
    # Рекурсивно:
    # check(3, 3) - внешние узлы (left.left vs right.right)
    # Значения равны (3 == 3)
    # Оба потомка None - None
    # check(4, 4) - внутренние узлы (left.right vs right.left)
    # Значения равны (4 == 4)
    # Оба потомка None - None
    # Возвращает True and True - True
    # Итог: дерево симметрично.

    # Полный алгоритм шаг за шагом:
    # 1. Начало: вызываем isSymmetric(root)
    # 2. Корень: если корень пустой - True
    # 3. Первое сравнение: сравниваем root.left и root.right
    # 4. Рекурсивная проверка:
    # - если оба узла None - True
    # - если один None - False
    # - если значения разные - False
    # - Рекурсивно проверяем внешние и внутренние пары потомков.
    # 5. Возврат результата: результат распространяется по цепочке рекурсивных вызовов.

    # Ключевые особенности алгоритма:
    # 1. Рекурсивный подход: функция вызывает саму себя для обхода дерева.
    # 2. Глубина рекурсии: максимальная глубина равна высоте дерева.
    # 3. Сложность: O(n), где n - количество узлов (каждый узел посещается один раз).
    # 4. Память: O(h), где h - высота дерева (память стека вызовов).

    # Это классическое решение, которое оптимально по времени и понятно в реализации.
