# Импортируем List для аннотации типов.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:

    # Метод removeEelement принимает следующие параметры:
    # self - ссылка на экземпляр класса (стандарт для методов класса).
    # nums: List[int] - список целых чисел.
    # val: int - значение, которое нужно удалить.
    # -> int - метод возвращает целое число (кол-во оставшихся элементов).
    def removeElement(self, nums: List[int], val: int) -> int:

        # Запускаем счётчик, который будет:
        # 1. Считать количество элементов, не равных val.
        # 2. Указывать позицию для записи следующего "хорошего" элемента.
        k = 0

        # Проходим по всем индексам массива nums.
        # i будет принимать значения 0, 1, 2, ..., len(nums)-1
        for i in range(len(nums)):

            # Проверяем: равен ли текущий элемент значению val?
            # Если НЕ равен - это элемент, который нужно сохранить.
            if nums[i] != val:
                # Копируем текущий элемент (nums[i] в позицию k,
                # это "перезаписывает" массив на месте.
                nums[k] = nums[i]

                # Увеличиваем счётчик k на 1, так как мы нашли ещё один
                # элемент, не равный val.
                k += 1

        # Возвращаем k - количество элементов, не равных val.
        # После цикла в первых k элементах массива находятся
        # все элементы, не равные val.
        return k

# Пример работы кода.
if __name__ == "__main__":
    solution = Solution()

    # Пример 1.
    print('Пример 1:')
    nums1 = [3, 2, 2, 3]
    val1 = 3
    print(f'Исходный массив: {nums1}')
    print(f'Значение для удаления: {val1}')

    k1 = solution.removeElement(nums1, val1)
    print(f'Количество элементов после удаления: {k1}')
    print(f'Первые {k1} элементов массива: {nums1[:k1]}')
    print(f'Весь массив после обработки: {nums1}')
    print('-' * 50)

    # Пример 2.
    print('Пример 2:')
    nums2 = [0, 1, 2, 2, 3, 0, 4, 2]
    val2 = 0
    print(f'Исходный массив: {nums2}')
    print(f'Значение для удаления: {val2}')

    k2 = solution.removeElement(nums2, val2)
    print(f'Количество элементов после удаления: {k2}')
    print(f'Первые {k2} элементов массива: {nums2[:k2]}')
    print(f'Весь массив после обработки: {nums2}')
    print('-' * 50)

    # Пример 3 (нет удаляемых значений).
    print('Пример 3:')
    nums3 = [1, 2, 3, 4, 5]
    val3 = 10
    print(f'Исходный массив: {nums3}')
    print(f'Значение для удаления: {val3}')

    k3 = solution.removeElement(nums3, val3)
    print(f'Количество элементов после удаления: {k3}')
    print(f'Первые {k3} элементов массива: {nums3[:k3]}')
    print(f'Весь массив после обработки: {nums3}')
    print('-' * 50)

    # Пример 4 (удалить все элементы!)
    print('Пример 4:')
    nums4 = [7, 7, 7, 7]
    val4 = 7
    print(f'Исходный массив: {nums4}')
    print(f'Значение для удаления: {val4}')

    k4 = solution.removeElement(nums4, val4)
    print(f'Количество элементов после удаления: {k4}')
    print(f'Первые {k4} элементов массива: {nums4[:k4]}')
    print(f'Весь массив после обработки: {nums4}')
    print('-' * 50)

# Алгоритм не удаляет и не обнуляет оставшиеся элементы. Он просто переставляет
# элементы так, что все "нужные" (не равные val) оказываются в начале массива.
# Пример 1: [3, 2, 2, 3], val = 3
# Мы нашли элементы 2 и 2 на позициях 1 и 2.
# Записали их в позиции 0 и 1 (используя указатель k).
# Элемент на позициях 2 и 3 остались без изменений (они были 2 и 3).
# Получился массив [2, 2, 2, 3].
# Почему так происходит?
# Алгоритм работает по принципу "два указателя":
# i идёт по всему массиву и проверяет каждый элемент.
# k указывает, куда положить следующий "хороший" элемент.
# Когда мы находим "хороший" элемент, мы копируем его в позицию k.
# Но при этом мы не удаляем оригинал!
