# Напишите функцию, которая находит самый длинный общий префикс среди массива строк.
# Если общего префикса нет, верните пустую строку ''.

# Пример 1:
# Ввод: strs = ['flower', 'flow', 'flight']
# Вывод: 'fl'

# Пример 2:
# Ввод: strs = ['dog', 'racecar', 'car']
# Вывод: ''

# Почему так? Во втором примере среди входных строк нет общего префикса.

# Импортируем тип List из модуля typing для аннотации типов.
# Это нужно для указания типа параметра функции.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:

    # Заводим метод класса, который принимает список строк (strs)
    # и возвращает строку (str).
    # self - ссылка на экземпляр класса (стандартно для методов класса).
    def longestCommonPrefix(self, strs: List[str]) -> str:

        # Проверяем, не является ли список strs пустым.
        # Если список пуст (not strs вернет True).
        if not strs:

            # Возвращаем пустую строку, так как в пустом списке нет общего префикса.
            return ''

        # Берём первую строку из списка как основу для сравнения.
        first_str = strs[0]

        # Начинаем цикл по индексам символов первой строки.
        # i будет принимать значения: 0, 1, 2, ..., len(first_str)-1
        # Перебираем каждый символ первой строки по порядку.
        for i in range(len(first_str)):

            # Получаем текущий символ из первой строки по индексу i.
            # Например, если first_str = 'flower' и i = 0, то current_char = 'f'
            current_char = first_str[i]

            # Внутренний цикл: проходим по всем строкам из списка, КРОМЕ первой.
            # strs[1:] - это срез списка от индекса 1 до конца.
            # s будет по очереди принимать каждую строку из оставшегося списка.
            for s in strs[1:]:

                # Проверяем два условия:
                # 1. i >= len(s) - проверяем, не выходим ли мы за границы текущей строки s
                # Если i больше или равен длине строки s, значит строка s короче,
                # чем первая строка, и общего префикса дальше нет.
                # 2. s[i] != current_char - проверяем, совпадает ли символ в позиции i
                # в текущей строке s с символом из первой строки.
                if i >= len(s) or s[i] != current_char:

                    # Если любое из условий выполнялось (True), значит общий префикс закончился.
                    # Возвращаем срез первой строки от начала до индекса i (не включая i).
                    # Пример: first_str = 'flower', i = 2 -> возвращаем 'fl'
                    return first_str[:i]

        # Если мы дошли до конца внешнего цикла (прошли все символы первой строки)
        # и ни разу не сработал return внутри циклов, значит вся первая строка
        # является общим префиксом для всех строк.
        # Возвращаем первую строку целиком.
        return first_str

# Точка входа в программу.
if __name__ == '__main__':
    solution = Solution()

# Пример 1.
    print(solution.longestCommonPrefix(['flower', 'flow', 'flight'])) # fl

# Пример 2.
    print(solution.longestCommonPrefix(['dog', 'racecar', 'car'])) # '' # это

# Пример 3.
    print(solution.longestCommonPrefix(['apple', 'app', 'april'])) # ap

    print(solution.longestCommonPrefix([''])) # '' # и это, понятное дело, не выводит, так как тут ничего нет.

    print(solution.longestCommonPrefix(['same', 'same', 'same'])) # same

# Как работает алгоритм?
# Проверка пустого массива: если массив пустой, сразу возвращаем пустую строку.
# Базовый подход:
# - берём первую строку как основу для сравнения
# - посимвольно проверяем, совпадает ли символ в этой позиции во ВСЕХ строках.
# Процесс сравнения:
# - проходим по каждому символу первой строки
# - для каждого символа проверяем все остальные строки
# - если в какой-то строке:
#       этот символ отсутствует (строка короче)
#       или символ отличается
#       тогда возвращаем подстроку первой строки до текущего индекса
# Крайние случаи:
# - если две строки одинаковые, возвращаем первую строку полностью
# - если есть пустая строка в массиве, префикс будет пустой строкой.
# Временная сложность: O(S), где S - сумма длин всех строк.
# Пространственная сложность: O(1) (не используем дополнительную память).
