# Импортируем тип List из модуля typing.
# List - это аннотация для списка. Помогает понять, что функция ожидает список.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Определяем метод sortByBits, который принимает в себя ряд параметров.
    # self - ссылка на сам объект.
    # arr: List[int] - список целых чисел.
    # -> List[int] - говорит нам о том, что метод возвращает список целых чисел.
    def sortByBits(self, arr: List[int]) -> List[int]:

    # Возвращает отсортированную версию входного массива.

    # sorted() - встроенная функция Питона, которая возвращает новый отсортированный список.
    # arr - исходный список для сортировки.
    # key - функция, определяющая критерии сортировки.

    # lambda x: (bin(x).count('1'), x) -
    # lambda - создаём анонимную функцию,
    # x - каждый элемент массива по очереди,
    # : - разделяем параметры и тело функции,
    # bin(x) - преобразуем число x в двоичную строку, например:
    # bin(0) -> '0b0'
    # bin(1) -> '0b1'
    # bin(2) -> '0b10'
    # bin(3) -> '0b11'
    # bin(4) -> '0b100'
    # .count('1') - считает количество символов '1' в строке:
    # '0b0'.count('1') -> 0
    # '0b1'.count('1') -> 1
    # '0b10'.count('1') -> 1
    # '0b11'.count('1') -> 2
    # '0b100'.count('1') -> 1
    # (bin(x).count('1'), x) - создаём кортеж из двух элементов:
    # первый элемент - количество единичных битов,
    # второй элемент - само число.
        return sorted(arr, key=lambda x: (bin(x).count('1'), x))

    # Как работает сортировка с кортежем:
    # Python сортирует кортежи как слова в словаре:
    # 1. Сначала сравниваются первые элементы кортежей.
    # 2. Если они равны, сравниваются вторые элементы.
    # 3. Если и они равны, переходим к третьим и т.д.

# Создаём экземпляр класса.
solution = Solution()

print()

# Пример 1.
arr1 = [0, 1, 2, 3, 4, 5, 6, 7, 8]
result1 = solution.sortByBits(arr1)
print(f'Входные данные: {arr1}')
print(f'Результат: {result1}')
print(f'Ожидаемый результат: [0, 1, 2, 4, 8, 3, 5, 6, 7]')
print(f'Совпадает: {result1 == [0, 1, 2, 4, 8, 3, 5, 6, 7]}')
print('-' * 70)

# Пример 2.
arr2 = [1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
result2 = solution.sortByBits(arr2)
print(f'Входные данные: {arr2}')
print(f'Результат: {result2}')
print(f'Ожидаемый результат: [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]')
print(f'Совпадает: {result2 == [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]}')
print('-' * 70)

# Дополнительный пример со смешанными значениями.
arr3 = [7, 3, 5, 1, 2, 4, 8, 6, 0]
result3 = solution.sortByBits(arr3)
print(f'Входные данные: {arr3}')
print(f'Результат: {result3}')
print(f'Ожидаемый результат (в порядке возрастания битов): [0, 1, 2, 4, 8, 3, 5, 6, 7]')
print(f'Совпадает: {result3 == [0, 1, 2, 4, 8, 3, 5, 6, 7]}')
print('-' * 70)

# Показательный пример с выводом двоичного представления.
print('Демонстрация работы сортировки:')
test_arr = [0, 1, 2, 3, 4, 5, 6, 7]
print('Число | Бинарно | Кол-во битов | Кортеж для сортировки')
print('-' * 70)
for num in test_arr:
    binary = bin(num)[2:] # убираем префикс '0b'
    bits_count = bin(num).count('1')
    sort_key = (bits_count, num)
    print(f'{num:5} | {binary:7} | {bits_count:11} | {sort_key}')
print('\nОтсортированный результат:', solution.sortByBits(test_arr))
