# Sort Integers by The Number of 1 Bits

# Сортировка целых чисел по количеству единичных битов.

# Вам дан целочисленный массив arr. Отсортируйте целые числа в массиве по возрастанию
# количества единиц (1) в их двоичном представлении. В случае, если два или более
# числа имеют одинаковое количество единиц, отсортируйте их по возрастанию (по значению).

# Верните отсортированный массив.

# Пример 1:
# Входные данные: arr = [0, 1, 2, 3, 4, 5, 6, 7, 8]
# Выходные данные: [0, 1, 2, 4, 8, 3, 5, 6, 7]
# Пояснение:
# [0] - единственное число с 0 битов.
# [1, 2, 4, 8] - все имеют по 1 биту.
# [3, 5, 6] - имеют по 2 бита.
# [7] - имеет 3 бита.
# Массив, отсортированный по количеству битов: [0, 1, 2, 4, 8, 3, 5, 6, 7]

# Пример 2:
# Входные данные: arr = [1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
# Выходные данные: [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
# Пояснение: все целые числа имеют по 1 биту в двоичном представлении,
# поэтому вы просто должны отсортировать их по возрастанию.

# Ограничения:
# длина массива: 1 <= arr.length <= 500
# Значения элементов: 0 <= arr[i] <= 10⁴

from typing import List

class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:

        return sorted(arr, key=lambda x: (bin(x).count('1'), x))

# Как это работает:
# 1. bin(x) - преобразует число в двоичную строку (например, bin(5) = '0b01')
# 2. .count('1') - считает количество едениц в двоичном представлении
# 3. lambda x: (bin(x).count('1'), x) - создаёт кортеж из двух элементов: количество
# битов и само число.
# 4. sorted() - сортирует сначала по первому элементу кортежа (количество битов),
# а при равенстве по второму (само число)

# Временная сложность: O(n log n), где n - длина массива
# Пространственная сложность: O(n) для хранения отсортированного массива