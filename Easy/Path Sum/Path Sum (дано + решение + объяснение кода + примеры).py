# Дано: корень бинарного дерева root и целое число targetSum.
# Верните true, если в дереве существует путь от корня до листа,
# такой что сумма всех значений вдоль пути равна targetSum.

# Лист - это узел, у которого нет дочерних узлов.

# Пример 1:
# Ввод: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
# Вывод: true
# Пояснение: путь от корня до листа с целевой суммой показан на изображении.

# Пример 2:
# Ввод: root = [1,2,3], targetSum = 5
# Вывод: false
# Пояснение: в дереве есть два пути от корня до листа:
# (1 --> 2): Сумма равна 3.
# (1 --> 3): Сумма равна 4.
# Нет пути от корня до листа с суммой = 5.

# Пример 3:
# Ввод: root = [], targetSum = 0
# Вывод: false
# Пояснение: Поскольку дерево пустое, путей от корня до листа не существует.

# Ограничения:
# Количество узлов в дереве находится в диапазоне [0, 5000].
# -1000 <= Node.val <= 1000
# -1000 <= targetSum <= 1000

# Заводим класс Solution, как того требует LeetCode.
class Solution:

    # Заводим метод hasPathSum, который принимает 3 параметра:
    # self - ссылка на текущий экземпляр класса (стандарт для методов класса в Питоне).
    # root - корневой узел бинарного дерева.
    # targetSum - целевая сумма, которую нужно найти на пути от корня до листа.
    def hasPathSum(self, root, targetSum):

        # Проверка на пустое дерево.
        # Проверяем, является ли root пустым, т.е. равным None, или null.
        # return False - если дерево пустое, возвращаем False, потому что
        # в пустом дереве нет путей вообще, и тем более нет пути с нужной нам суммой.
        # root = [] и targetSum = 0, мы сразу вернём False как в примере 3.
        if not root:
            return False

        # Проверяем, является ли текущий узел листом.
        # if not root.left and not root.right - проверяем, что у текущего узла НЕТ
        # левого потомка и НЕТ правого потомка.
        # Если оба условия верны - значит, это лист (конечная точка пути).
        # К этому моменту targetSum уже уменьшен на значения всех предыдущих узлов.
        # Если оставшийся targetSum равен значению этого листа - значит, мы нашли нужный путь.
        # Пример: если мы дошли до листа со значением 7, а targetSum сейчас равен 7 -> возвращаем True.
        if not root.left and not root.right:
            return targetSum == root.val

        # Рекурсивный поиск в поддеревьях.
        # Выполняем эту часть, если текущий узел НЕ является листом (у него есть хотя бы один потомок).

        # targetSum - root.val - мы вычитаем значение текущего узла из целевой суммы, потому что
        # если мы включаем этот узел в путь, то оставшуюся сумму нужно найти в продолжении пути.

        # self.hasPathSum(root.left, targetSum - root.val) - рекурсивный вызов для левого поддерева.
        # Мы говорим: "Проверь, есть ли в левом поддереве путь с суммой targetSum - root.val"

        # self.hasPathSum(root.right, targetSum - root.val) - рекурсвиный вызов для правого поддерева.

        return (self.hasPathSum(root.left, targetSum - root.val) or
                self.hasPathSum(root.right, targetSum - root.val))

# Пример 1: Корректный путь существует

# Дерево:
#       5
#      / \
#     4   8
#    /   / \
#   11  13  4
#  /  \      \
# 7    2      1

# Путь: 5 > 4 > 11 > 2 (сумма = 22)

print("Пример 1:")
print("Корень: 5")
print("Целевая сумма: 22")
print("Ожидается: True")
print("Путь: 5 > 4 > 11 > 2")
print()

# ----------------------------------------------------------- #

# Пример 2: Нет подходящего пути

# Дерево:
#     1
#    / \
#   2   3

# Пути: 1 > 2 (сумма = 3), 1 > 3 (сумма = 4)

print("Пример 2:")
print("Корень: 1")
print("Целевая сумма: 5")
print("Ожидается: False")
print("Пути: 1 > 2 (сумма = 3), 1 > 3 (сумма = 4)")
print()

# ----------------------------------------------------------- #

# Пример 3: Пустое дерево

print("Пример 3:")
print("Корень: None (пустое дерево)")
print("Целевая сумма: 0")
print("Ожидается: False")
print("Объяснение: В пустом дереве нет путей")
print()

# ----------------------------------------------------------- #

# Пример 4: Дерево с одним узлом

# Дерево:
#     1

print("Пример 4:")
print("Корень: 1")
print("Целевая сумма: 1")
print("Ожидается: True")
print("Путь: [1] (сумма = 1)")
print()

# ----------------------------------------------------------- #

# Пример 5: Отрицательные значения

# Дерево:
#     -2
#       \
#        -3

# Путь: -2 > -3 (сумма = -5)

print("Пример 5:")
print("Корень: -2")
print("Целевая сумма: -5")
print("Ожидается: True")
print("Путь: -2 > -3 (сумма = -5)")
print()

# ----------------------------------------------------------- #

# Пример 6: Сложное дерево без подходящего пути

# Дерево:

#       1
#      / \
#     2   3
#    /   / \
#   4   5   6

print("Пример 6:")
print("Корень: 1")
print("Целевая сумма: 100")
print("Ожидается: False")
print("Пути: 1 > 2 > 4 (7), 1 > 3 > 5 (9), 1 > 3 > 6 (10)")
print()

# ----------------------------------------------------------- #

# Пример 7: Дерево с нулевыми значениями

# Дерево:
#       0
#      / \
#     1   0
#        / \
#       1   0
#      /
#     1

print("Пример 7:")
print("Корень: 0")
print("Целевая сумма: 2")
print("Ожидается: True")
print("Путь: 0 > 0 > 1 > 1 (0 + 0 + 1 + 1 = 2)")
print()

# ----------------------------------------------------------- #

# Пример 8: Дерево с одинаковыми значениями

# Дерево:
#       1
#      / \
#     1   1
#    / \   \
#   1   1   1

print("Пример 8:")
print("Корень: 1")
print("Целевая сумма: 3")
print("Ожидается: True")
print("Путей много - слева, справа, в центре. Везде будет одинаково: 1 > 1 > 1")

# ----------------------------------------------------------- #