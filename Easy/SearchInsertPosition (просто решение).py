# Дан отсортированный массив различных целых чисел и целевое значение.
# Верните индекс, если цель найдена. Если нет, верните индекс, куда
# оно было бы вставлено, чтобы сохранить порядок.

# Нужно написать алгоритм со сложностью выполнения O(log n).

# Примеры выполнения:
# Вход: nums = [1,3,5,6], target = 5
# Выход: 2   (5 находится на индексе 2)

# Вход: nums = [1,3,5,6], target = 2
# Выход: 1   (2 было бы вставлено на индекс 1: [1,2,3,5,6])

# Вход: nums = [1,3,5,6], target = 7
# Выход: 4   (7 было бы вставлено в конец)

from typing import List

class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1

        while left <= right:
            mid = (left + right) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        solution = Solution()
        print(solution.searchInsert([1, 3, 5, 6], 5))  # 2
        print(solution.searchInsert([1, 3, 5, 6], 2))  # 1
        print(solution.searchInsert([1, 3, 5, 6], 7))  # 4
        print(solution.searchInsert([1, 3, 5, 6], 0))  # 0

        # Если элемент не найден, left указывает на позицию для вставки.
        
        return left

    # Как это работает:
    # left и right — границы поиска в массиве
    # Находим средний элемент (mid)
    # Если нашли target — возвращаем его индекс
    # Если target больше среднего — ищем в правой половине
    # Если target меньше среднего — ищем в левой половине
    # Если элемент не найден после цикла, left указывает на позицию, куда его нужно вставить

    # Почему возвращаем left:

    # После завершения цикла left > right
    # left всегда указывает на позицию, где должен находиться target для сохранения порядка.

    # Это стандартное свойство бинарного поиска при поиске позиции вставки.

    # Сложность алгоритма: O(log n), как и требуется в условии.
