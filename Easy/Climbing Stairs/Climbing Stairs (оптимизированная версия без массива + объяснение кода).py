# Оптимизированная версия без массива.
# Эта оптимизированная версия использует O(1) памяти вместо O(n).

# Заводим класс Solution.
class Solution:

    # Заводим метод climbStairs.
    # Метод принимает целое число n (количество ступенек)
    # и возвращает целое число (количество способов).
    def climbStairs(self, n: int) -> int:

        # Базовый случай: если всего 1 ступенька,
        # то только 1 способ подняться (1 шаг).
        if n == 1:
            return 1

        # Базовый случай: если 2 ступеньки,
        # то 2 способа: 1+1 или 2 шага.
        if n == 2:
            return 2

        # Используем только 2 переменные вместо массива.
        # prev1 хранит количество способов для предыдущей ступеньки.
        # Для n=2 это 2 способа.
        prev1 = 2 # для i-1

        # prev2 хранит количество способов для ступеньки на две ниже.
        # Для n=1 это 1 способ.
        prev2 = 1 # для i-2

        # Цикл от 3 до n включительно (n + 1).
        # Так как для n=1 и n=2 мы уже обработали выше, начинаем c i=3
        for i in range(3, n + 1):

            # Количество способов для текущей ступеньки i
            # равно сумме способов для (i-1) и (i-2).
            # Это следует из того, что на последнем шаге
            # мы можем сделать либо 1 шаг, либо 2 шага.
            current = prev1 + prev2

            # Обновляем переменные для следующей итерации:
            # 1. prev2 становится тем, что было prev1 (ступенька i-1)
            # 2. prev1 становится current (стуенька i).
            # Это "сдвиг" значения для следующей итерации цикла.
            prev2, prev1 = prev1, current

        # После завершения цикла prev1 содержит
        # количество способов для n-й ступеньки.
        # Возвращаем это значение.
        return prev1
