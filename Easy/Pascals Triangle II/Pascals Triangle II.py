# Учитывая целочисленный rowIndex, верни rowIndex-Ю (с нуля) строку треугольника Паскаля.

# В треугольнике Паскаля каждое число равно сумме двух чисел, расположенных непосредственно
# над ним, как показано в гифке в примере.

# Пример 1:
# Вход: rowIndex = 3
# Выход: [1,3,3,1]

# Пример 2:
# Вход: rowIndex = 0
# Выход: [1]

# Пример 3:
# Вход: rowIndex = 1
# Выход: [1,1]

# Ограничения:
# 0 ≤ rowIndex ≤ 33

# Дополнительное задание:
# Сможешь ли ты оптимизировать алгоритм так, чтобы использовать только 0(rowIndex)
# дополнительной памяти ?

# Импортируем List из модуля typing.
# Это нужно для аннотации типов, чтобы указать, что функция возвращает список целых чисел.
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод getRow, который принимает в себя ряд параметров.
    # rowIndex - номер строки треугольника Паскаля (начиная с нуля).
    # -> List[int] - возвращает список целых чисел, т.е. эту строку.
    def getRow(self, rowIndex: int) -> List[int]:

        # Создание массива результата.
        # Создаём список row длиной rowIndex + 1, заполненный единицами.
        # Почему rowIndex + 1?
        # Если rowIndex = 0 -> строка содержит 1 элемент.
        # Если rowIndex = 3 -> строка содержит 4 элемента.
        # Длина всегда = rowIndex + 1.
        # Почему заполняем единицами?
        # Потому что первый и последний элементы любой строки треугольника Паскаля равны 1.
        # Например, для rowIndex = 3 правильный ответ [1, 3, 3, 1].
        # Мы начинаемс [1, 1, 1, 1], а потом пересчитаем внутренние элементы.
        row = [1] * (rowIndex + 1)

        # Запускаем цикл for, заполняем внутренние элементы.
        # Проходим по индексам от 1 до rowIndex -1 включительно.
        # Это все позиции, кроме самого первого (индекс 0) и самого последнего (индекс rowIndex).
        # Именно эти внутренние позиции не равны 1 в общем случае, их нужно вычислить.
        # Пример:
        # rowIndex = 3 -> range(1, 3) даст k = 1, 2.
        # Значит, мы пересчитаем элементы с индексами 1 и 2.
        for k in range(1, rowIndex):

            # Считаем значение по формуле.
            # Здесь используется итеративная формула биноминального коэффициента:
            # см. файл "формула.jpg"
            # Почему эта формула работает?
            # Элемент строки треугольника Паскаля с индексом k (начиная с 0) равен биноминальному
            # коэффициенту C(n,k).
            # Если мы уже знаем предыдущий коэффициент C(n,k - 1), то следующий можно получить
            # домножением и делением.

            # Детальный разбор для rowIndex = 3:
            # Начало:
            # row = [1, 1, 1, 1]
            # k = 1:
            # row[1] = row[0] * (3 - 1 + 1) // 1
            # row[1] = 1 * (3) // 1 = 3
            # row = [1, 3, 1, 1]
            # k = 2:
            # row[2] = row[1] * (3 - 2 + 1) // 2
            # row[2] = 3 * (2) // 2 = 3
            # row = [1, 3, 3, 1]
            # Готово!

            # Почему используем // (целочисленное деление) ?
            # Потому что все промежуточные значения - целые числа, и результат деления всегда целый.
            # Если бы мы использовали обычное /, получили бы float, что не соответствует требуемому
            # типу данных List[int].

            row[k] = row[k-1] * (rowIndex - k + 1) // k

        return row # Вертаем результат.

print("Вход: rowIndex = 5")
print()
print("row = [1, 1, 1, 1, 1, 1]")
print()
print("k = 1: row[1] = 1 * (5 - 1 + 1) // 1 = 5 → [1, 5, 1, 1, 1, 1]")
print("k = 2: row[2] = 5 * (5 - 2 + 1) // 2 = 5 * 4 // 2 = 10 --> [1, 5, 10, 1, 1, 1]")
print("k = 3: row[3] = 10 * (5 - 3 + 1) // 3 = 10 * 3 // 3 = 10 --> [1, 5, 10, 10, 1, 1]")
print("k = 4: row[4] = 10 * (5 - 4 + 1) // 4 = 10 * 2 // 4 = 5 --> [1, 5, 10, 10, 5, 1]")
print()
print("Выход: [1, 5, 10, 10, 5, 1] [V]")

# Почему первая и последняя еденицы не фигурируют в примере?
# Они уже стоят на своих местах с самого начала, их не нужно вычислять - они всегда 1.
# Цикл for их просто обходит. Цикл for работает только с индексами от 1 до 4.