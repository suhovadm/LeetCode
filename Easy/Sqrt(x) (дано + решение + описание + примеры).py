# Дано неотрицательное целое число x. Верните квадратный корень из x, округлённый вниз до
# ближайшего целого числа. Возвращаемое число также должно быть неотрицательным.

# Вы не должны использовать встроенную функцию или оператор для возведения в степень.

# Например, нельзя использовать pow(x, 0.5) в C++ или x ** 0.5 в Python.

# Пример 1:
# Ввод: x = 4
# Вывод: 2
# Объяснение: квадратный корень из 4 равен 2, поэтому возвращаем 2.

# Пример 2:
# Ввод: 2
# Объяснение: квадратный корень из 8 примерно равен 2,82842..., и после округления вниз
# до ближайшего целого числа получаем 2.

# Максимально простой и понятный вариант решения с использованием бинарного поиска:

# Объявляем класс Solution.
class Solution:

    # Определяем метод mySqrt, который принимает:
    # self - ссылка на экземпляр класса.
    # x: int - входное целое число.
    # -> int - метод возвращает целое число.
    def mySqrt(self, x: int) -> int:

        # Если x равно 0 или 1, то квадратный корень равен самому x.
        # Например √0 = 0, √1 = 1
        # Это упрощает дальнейшие вычисления.
        if x < 2:
            return x

        # Заводим границы поиска:
        # left = 0 - минимально возможный корень.
        # right = x - максимально возможный корень (так как √x всегда ≤ x при x ≥ 1).
        left, right = 0, x

        # Начало цикла бинарного поиска:
        # Цикл продолжается, пока диапазон поиска не сократится до нуля
        # left <= right означает, что есть хотя бы одно число для проверки.
        while left <= right:

            # Вычисление середины диапазона:
            # // - целочисленное деление (округляем вниз).
            # Находим середину текущего интервала поиска.
            # Пример: если left=0, right=8 -> mid=(0+8) // 2 = 4.
            mid = (left + right) // 2

            # Вычисление квадрата среднего значения:
            # Умножаем mid на себя, чтобы получить квадрат.
            # Проверяем, не равен ли этот квадрат исходному числу x.
            square = mid * mid

            # Нашли точный квадратный корень:
            # если квадрат mid точно равен x возвращаем mid как ответ.
            # Пример: x=9, mid=3 -> 3*3=9 -> возвращаем 3.
            if square == x:
                return mid

            # Квадрат меньше нужного значения:
            # если mid² < x, значит нужный корень больше текущего mid.
            # Сдвигаем левую границу вправо: left = mid + 1.
            # Пример: x=10, mid=3 -> 9<10 -> ищем в диапазоне [4, right].
            elif square < x:
                left = mid + 1

            # Квадрат больше нужного значения:
            # если mid² > x, значит нужный корень меньше текущего mid.
            # Сдвигаем правую границу влево: right = mid - 1.
            # Пример: x=10, mid=4 -> 16>10 -> ищем в диапазоне [left, 3].
            else:
                right = mid -1

        # Возврат результата (выходим из цикла).
        # Когда цикл завершается ( left > right ), right содержит ответ.
        # Почему right? Потому что:
        # 1. На последнем шаге mid дал квадрат больше x.
        # 2. Мы уменьшили right до mid - 1.
        # 3. Это наибольшее число, квадрат которого ≤ x.
        return right

# Объяснение работы бинарного поиска:
# 1. Мы ищем целое число между 0 и x, квадрат которого равен x или максимально близок,
# но не превышает его.
# 2. Если квадрат середины равен x - нашли точный корень.
# 3. Если квадрат меньше x - двигаем левую границу вправо.
# 4. Если квадрат больше x - двигаем правую границу влево.
# 5. В конце цикла right содержит округлённый вниз корень.

# Пример работы:
solution = Solution()
print('Квадратный корень из 4: ', solution.mySqrt(4)) # 2
print('Квадратный корень из 8: ', solution.mySqrt(8)) # 2 (так как 2*2=4 < 8, а 3*3=9 > 8)
print('Квадратный корень из 0: ', solution.mySqrt(0)) # 0
print('Квадратный корень из 1: ', solution.mySqrt(1)) # 1

# Пример выполнения для x = 8:
# Итерация 1: left=0, right=8, mid=4, 4*4=16 > 8 → right=3
# Итерация 2: left=0, right=3, mid=1, 1*1=1 < 8 → left=2
# Итерация 3: left=2, right=3, mid=2, 2*2=4 < 8 → left=3
# Итерация 4: left=3, right=3, mid=3, 3*3=9 > 8 → right=2
# Цикл завершен (3 > 2)
# Возвращаем right=2 ✓
