# Дан массив целых чисел nums и целое число val.
# Удалите все вхождения val в массиве nums на месте (in-place).
# Порядок элементов может быть изменён. Затем верните кол-во элементов в nums, которые не равны val.

# Пусть кол-во элементов, не равных val, равно k. Чтобы решение было принято, необходимо сделать
# следующее:
# 1. Изменить массив nums таким образом, чтобы первые k элементов содержали элементы, не
# равные val. Остальные элементы nums, а также размер nums, не имеют значения.
# 2. Вернуть k.

# Проверяющая система (custom judge):
# Решение будет проверяться следующим кодом:
# int[] nums = [...]; // Входной массив.
# int val = ...; // Значение для удаления.
# int [] expectedNums = [...]; // Ожидаемый ответ с правильной длиной.
#                              // Отсортирован, не содержит значений, равных val.

# int k = removeElement(nums, val); // Вызов вашей реализации.

# assert k == expectedNums.length;
# sort(nums, 0, k); // Сортировка первых k элементов nums
# for (int i = 0; i < actualLength; i++) {
#     assert nums[i] == expectedNums[i];
# }
# Если все утверждения верны, решение будет принято.

# Пример 1:
# Вывод nums = [3, 2, 2, 3], val = 3
# Вывод: 2, nums = [2, 2,,]
# Объяснение: ваша функция должна вернуть k = 2, при этом первые два элемента nums будут равны 2.
# Не имеет значения, что остаётся за пределами возвращаемого k (поэтому они обозначены подчёркиванием).

# Пример 2:
# Вывод: nums = [0, 1, 2, 2, 3, 0, 4, 2], val = 2
# Вывод: 5, nums = [0, 1, 4, 0, 3,,, _]
# Объяснение: ваша функция должна вернуть k = 5, при этом первые пять элементов nums содержат
# 0, 0, 1, 3 и 4.
# Заметьте, что эти пять элементов могут быть возвращены в любом порядке.
# Не имеет значения, что останется за пределами возвращаемого k (поэтому они обозначены
# подчёркиванием).

from typing import List

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:

        k = 0

        for i in range(len(nums)):

            if nums[i] != val:
                nums[k] = nums[i]

                k += 1

        return k

# 1)
# Мы используем два указателя:
# i - проходит по всему исходному массиву.
# k - отслеживает позицию, куда нужно записать следующий элемент, не равный val.

# 2)
# Проходим по всем элементам массива nums:
# если элемент не равен val, копируем его в позицию k и увеличиваем k на 1.
# Если элемент равен val, просто пропускаем его.

# 3)
# В первых k позициях массива находятся все элементы, не равные val.
# Возвращаем значение k (количество оставшихся элементов).

# Пример использования:
# solution = Solution()
# nums = [3, 2, 2, 3]
# val = 3
# k = solution.removeElement(nums, val)
# print(k)  # Вывод: 2
# print(nums[:k])  # Вывод: [2, 2]

# Решение имеет:
# Временную сложность O(n) - проходим по массиву один раз.
# Пространственную сложность O(1) - используем только константную дополнительную память.
