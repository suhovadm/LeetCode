# Дан отсортированный массив различных целых чисел и целевое значение.
# Верните индекс, если цель найдена. Если нет, верните индекс, куда
# оно было бы вставлено, чтобы сохранить порядок.

# Нужно написать алгоритм со сложностью выполнения O(log n).

# Примеры выполнения:
# Вход: nums = [1,3,5,6], target = 5
# Выход: 2   (5 находится на индексе 2)

# Вход: nums = [1,3,5,6], target = 2
# Выход: 1   (2 было бы вставлено на индекс 1: [1,2,3,5,6])

# Вход: nums = [1,3,5,6], target = 7
# Выход: 4   (7 было бы вставлено в конец)

# Импортируем тип List из модуля typing для аннотации типов параметров.
from typing import List

# Заводим класс Solution, как требуется на LeetCode.
class Solution:

    # Объявляем метод searchInsert, который принимает в себя следующие параметры:
    # self - стандартный первый параметр для методов класса.
    # nums: List[int] - список целых чисел (отсортированный по возрастанию, без дублей).
    # target: int - целое число, которое мы ищем.
    # -> int - метод возвращает целое число (индекс).
    def searchInsert(self, nums: List[int], target: int) -> int:

        # Заводим две переменные:
        # left = 0 - левая граница поиска (начальный индекс массива).
        # right = len(nums) - 1 - правая граница поиска (индекс последнего элемента).
        # Пример для nums = [1, 3, 5, 6] -> left = 0, right = 3
        left, right = 0, len(nums) - 1

        # Начинаем цикл бинарного поиска. Условие left <= right означает:
        # пока диапазон поиска не пуст (левая граница не превысила правую), продолжаем поиск.
        # Если left > right, значит, мы проверили весь диапазон и не нашли элемент.
        while left <= right:

            # Вычисляем индекс среднего элемента.
            # (left + right) // 2 - целочисленное деление на 2 (берём нижнюю границу).
            # Пример: left = 0, right = 3 -> mid = (0 + 3) // 2 = 1
            mid = (left + right) // 2

            # Случай 1: если элемент в середине ( nums[mid] ) равен целевому значению ( target ):
            # мы нашли искомый элемент -> немедленно возвращаем его индекс mid.
            # Пример: nums[1] = 3, target = 3 -> возвращаем 1.
            if nums[mid] == target:
                return mid

            # Случай 2: если элемент в середине меньше целевого значения:
            # значит, target находится в правой половине текущего диапазона (поскольку
            # массив отсортирован).
            # Сужаем диапазон: сдвигаем левую границу за середину -> left = mid + 1.
            # Пример: nums[1] = 3, target = 5 -> 3 < 5 -> ищем справа, left = 2.
            elif nums[mid] < target:
                left = mid + 1

            # Случай 3: если элемент в середине больше целевого значения:
            # значит, target находится в левой половине текущего диапазона.
            # Сужаем диапазон: сдвигаем правую границу перед серединой -> right = mid - 1.
            # Пример: nums[1] = 3, target = 2 -> 3 > 2 -> ищем слева, right = 0.
            else:
                right = mid - 1

        solution = Solution()
        print(solution.searchInsert([1, 3, 5, 6], 5))  # 2
        print(solution.searchInsert([1, 3, 5, 6], 2))  # 1
        print(solution.searchInsert([1, 3, 5, 6], 7))  # 4
        print(solution.searchInsert([1, 3, 5, 6], 0))  # 0

        # Если цикл завершился (элемент не найден), возвращаем left.
        # Почему именно left?
        # На момент выхода из цикла: left > right.
        # Переменная left указывает на первую позицию, где nums[left] > target (или на
        # конец массива, если target больше всех элементов).
        # Это именно та позиция, куда нужно вставить target, чтобы сохранить порядок сортировки.
        return left

        # Пример для работы nums = [1, 3, 5, 6], target = 2:
        # Итерация 1:
        # left = 0, right = 3
        # mid = (0 + 3) // 2 = 1
        # nums[1] = 3
        # 3 > 2 -> right = mid - 1 = 0

        # Итерация 2:
        # left = 0, right = 0
        # mid = (0 + 0) // 2 = 0
        # nums[0] = 1

        # Итерация 3:
        # left = 1, right = 0 -> условие left <= right ложно (1 > 0) -> выходим из цикла.
        # Возвращаем left = 1 (позиция для вставки 2).

        # Сложность O(log n): на каждой итерации диапазон поиска уменьшается вдвое.
        # Условие left <= right: обрабатывает случай, когда диапазон состоит из одного элемента.
        # Возврат left при отсутствии элемента гарантирует корректную позицию для вставки.
        # Это классическая реализация бинарного поиска для поиска позиции вставки в отсортированном массиве.

    # Как это работает:
    # left и right — границы поиска в массиве
    # Находим средний элемент (mid)
    # Если нашли target — возвращаем его индекс
    # Если target больше среднего — ищем в правой половине
    # Если target меньше среднего — ищем в левой половине
    # Если элемент не найден после цикла, left указывает на позицию, куда его нужно вставить

    # Почему возвращаем left:

    # После завершения цикла left > right
    # left всегда указывает на позицию, где должен находиться target для сохранения порядка.

    # Это стандартное свойство бинарного поиска при поиске позиции вставки.

    # Сложность алгоритма: O(log n), как и требуется в условии.
