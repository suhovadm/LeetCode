# Импортируем List из модуля typing для аннотации типов
# (указания, что функция принимает список целых чисел).
from typing import List

# Заводим класс Solution, как того требует LeetCode.
class Solution:
    # Заводим метод plusOne, который принимает список
    # целых чисел digits и возвращает список целых чисел.
    def plusOne(self, digits: List[int]) -> List[int]:

        # Запускаем цикл, который проходит массив с конца к началу:
        # len(digits) -1 - индекс последнего элемента
        # -1 - до какого значения идём (не включая -1, т.е. до 0)
        # -1 - шаг (идём в обратном порядке).
        for i in range(len(digits) -1, -1, -1):

            # Если текущая цифра менье 9: увеличиваем её на 1.
            if digits[i] < 9:
                digits[i] += 1
                # Немедленно возвращаем результат (всё готово).
                return digits
            # Если цифра равна 9:
            # меняем её на 0 (произошёл перенос разряда).
            # Цикл продолжается, проверяя следующую цифру слева.
            digits[i] = 0

        # Если мы вышли из цикла, значит все цифры были 9 (например, [9,9,9]).
        # Вы этом случае все цифры стали 0, и нужно добавить 1 в начало.
        # [1] + digits создаёт новый список, где первым элементом будет 1, а затем все остальные
        # цифры (которые теперь все равны 0).
        return [1] + digits

# Создаём экземпляр класса.
solution = Solution()

print('=' * 50)
print('Пример 1: [1, 2, 3]')
print(f'Результат: {solution.plusOne([1, 2, 3])}')

print('\n' + '=' * 50)
print('Пример 2: [4, 3, 2, 1]')
print(f'Результат: {solution.plusOne([4, 3, 2, 1])}')

print('\n' + '=' * 50)
print('Пример 3: [9]')
print(f'Результат: {solution.plusOne([9])}')

print('\n' + '=' * 50)
print('Пример 4: [1, 2, 9]')
print(f'Результат: {solution.plusOne([1, 2, 9])}')

print('\n' + '=' * 50)
print('Пример 5: [9, 9, 9]')
print(f'Результат: {solution.plusOne([9, 9, 9])}')

# Ключевые моменты:
# 1. Работа с 9: когда встречаем цифру 9, меняем её на 0 и "переносим" 1 на след. разряд слева.
# 2. Эффективность: алгоритм обычно заканчивается быстро, если последняя цифра не 9.
# 3. Крайний случай: если все цифры 9, результат будет на 1 цифру длинее.
# 4. Сложность: O(n) в худщем случае, O(1) в лучшем случае (когда последняя цифра НЕ 9).

# Код крайне быстро и просто обрабатывает все возможные сценарии с минимальным количеством операций.
