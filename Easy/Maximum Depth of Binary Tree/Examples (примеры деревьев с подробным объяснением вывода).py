from Maximum_Depth_of_Binary_Tree import *

# --------------------------------------------------------------------------------------

# Пример 1: дерево [3, 9, 20, null, null, 15, 7]
print('Пример 1:')
#       3
#      / \
#     9   20
#        /  \
#       15   7

# Шаг 1: вызов maxDepth(3)
# root = 3, не None
# Вызываем maxDepth(9) для левого поддерева.

# Шаг 2: вызов maxDepth(9) (левое от 3)
# root = 9, не None
# Вызываем maxDepth(None) для левого от 9 - возвращает 0.
# Вызываем maxDepth(None) для правого от 9 - возвращает 0.
# Возвращаем max(0, 0) + 1 = 1
# * Глубина узла 9 = 1*

# Шаг 3: вызов maxDepth(20) (правое от 3)
# root = 20, не None
# Вызываем maxDepth(15) для левого от 20

# Шаг 4: вызов maxDepth(15) (левое от 20)
# root = 15, не None
# maxDepth(None) для левого - 0
# maxDepth(None) для правого - 0
# *Глубина узла 15 = 1*

# Шаг 5: вызов maxDepth(7) (правое от 20)
# root = 7, не None
# maxDepth(None) для левого - 0
# maxDepth(None) для правого - 0
# Возвращаем max(0, 0) + 1 = 1
# *Глубина узла 7 = 1*

# Шаг 6: возвращаемся к узлу 20.
# Имеем: левое поддерево (15) глубиной 1, правое поддерево (7) глубиной 1.
# Возвращаем max(1, 1) + 1 = 2
# *Глубина узла 20 = 2*

# Шаг 7: возвращаемся к корню 3.
# Имеем: левое поддерево (9) глубиной 1, правое поддерево (20) глубиной 2.
# Возвращаем max(1, 2) + 1 = 3
# *Глубина всего дерева = 3*

node15 = TreeNode(15)
node7 = TreeNode(7)
node20 = TreeNode(20, node15, node7)
node9 = TreeNode(9)
root1 = TreeNode(3, node9, node20)

solution = Solution()

print(f'Глубина дерева: {solution.maxDepth(root1)}')
print(f'Глубина левого дерева (9): {solution.maxDepth(root1.left)}')
print(f'Глубина правого дерева (20): {solution.maxDepth(root1.right)}')

# --------------------------------------------------------------------------------------

# Пример 2: дерево [1, null, 2]
print('\nПример 2:')
#   1
#    \
#     2

# Шаг 1: вызов maxDepth(1)
# root = 1, не None.
# Вызываем maxDepth(None) для левого - возвращаем 0.
# Вызываем maxDepth(2) для правого.

# Шаг 2: вызов maxDepth(2)
# root = 2, не None.
# maxDepth(None) для левого - 0.
# maxDepth(None) для правого - 0.
# Возвращаем max(0, 0) + 1 = 1.

# Шаг 3: возвращаемся к узлу 1.
# Имеем левое поддерево глубиной 0, правое поддерево глубиной 1.
# Возвращаем max(0, 1) + 1 = 2.

# Здесь получается левое поддерево = 0, правое поддерево = 1, а всё дерево = 2.

node2 = TreeNode(2)
root2 = TreeNode(1, None, node2)

print(f'Глубина дерева: {solution.maxDepth(root2)}')
print(f'Глубина левого поддерева: {solution.maxDepth(root2.left)}')
print(f'Глубина правого поддерева: {solution.maxDepth(root2.right)}')

# --------------------------------------------------------------------------------------

# Пример 3: пустое дерево.
print('\nПример 3: пустое дерево.')
print(f'Глубина: {solution.maxDepth(None)}')

# Здесь просто maxDepth(None) - сразу возвращаем 0.

# --------------------------------------------------------------------------------------

# Пример 4: дерево с одним узлом.
print('\nПример 4: дерево с одним узлом.')
root4 = TreeNode(1)
print(f'Глубина: {solution.maxDepth(root4)}')

# Шаг 1: вызов maxDepth(1)
# root = 1, не None
# maxDepth(None) для левого - 0
# maxDepth(None) для правого - 0
# Возвращаем max(0, 0) + 1 = 1

# --------------------------------------------------------------------------------------

# Пример 5: сбалансированное дерево глубиной 3.
print('\nПример 5: сбалансированное дерево.')
#       1
#      / \
#     2   3
#    / \   \
#   4   5   6

# 1. Листья (4, 5, 6): max(0, 0) + 1 = 1
# 2. Узел 2: левое (4) = 1, правое (5) = 1 - max(1, 1) + 1 = 2
# 3. Узел 3: левое = 0, правое (6) = 1 - max(0, 1) + 1 = 2
# Корень 1: левое (2) = 2, правое (3) = 2 - max(2, 2) + 1 = 3

# Глубина дерева: 3
# Глубина узла 2: 2
# Глубина узла 3: 2

# Узлы и их связи:
# Узел 1 (корень) - дети: 2 (левый), 3 (правый).
# Узел 2 - дети 4 (левый), 5 (правый).
# Узел 3 - дети: None (левый), 6 (правый).
# Узел 4 - дети: None, None (лист).
# Узел 5 - дети: None, None (лист).
# Узел 6 - дети: None, None (лист).

# Почему глубина дерева = 3?
# 1. 1 - 2 - 4 (3 узла).
# 2. 1 - 2 - 5 (3 узла).
# 3. 1 - 3 - 6 (3 узла).

# Глубина узла - это количество узлов на самом на самом длинном пути
# от этого узла до листа, включая сам узел. В этом дереве самый длинный
# путь содержит 3 узла, поэтому глубина дерева = 3.

node4 = TreeNode(4)
node5 = TreeNode(5)
node6 = TreeNode(6)
node2 = TreeNode(2, node4, node5)
node3 = TreeNode(3, None, node6)
root5 = TreeNode(1, node2, node3)

print(f'Глубина дерева: {solution.maxDepth(root5)}')
print(f'Глубина узла 2: {solution.maxDepth(node2)}')
print(f'Глубина узла 3: {solution.maxDepth(node3)}')

# --------------------------------------------------------------------------------------
